<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[结构体 以及内存对齐相关问题]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%BB%93%E6%9E%84%E4%BD%93-%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[结构体 及其内存对齐相关问题结构体结构体的声明1234struct tag&#123; number-list;&#125;variable-list; 例如描述一个学生 1234567struct stu&#123; char name[20]; //名字 int age; //年龄 char sex[5]; //性别 char id[20]; //学号&#125;;//分号不能没有 特殊的声明：在声明结构体的时候，可以不完全的声明 比如： 123456789101112131415//匿名结构体类型struct&#123; int a; char b; float c;&#125;x;struct&#123; int a; char b; float c;&#125;a[20],*p; 警告：编译器会把上面的两个声明当成完全不同的两个类型。所以是非法的 结构体的自引用1234567891011struct Node&#123; int data; struct Node* next;&#125;;typedef struct Node&#123; int data; struct Node* next;&#125;Node; 结构体变量的定义和初始化有了结构体类型，则如下定义变量 1234567891011121314151617181920212223242526struct Point&#123; int x; int y;&#125;p1; //声明类型的同时定义变量p1;struct point p2; //定义结构体变量p2//初始化：定义变量的同时赋初值struct Point p3 = &#123;x,y&#125;;struct Stu //类型声明&#123; char name[15]; //名字 int age; //年龄&#125;;struct Stu s = &#123;"zhangsan",20&#125;;//初始化struct Stu&#123; int data; struct Point p; struct Node* next;&#125;n1 = &#123;10,&#123;4,5&#125;,NULL&#125;; //结构体嵌套初始化struct Node n2 = &#123;20,&#123;5,6&#125;,NULL&#125;; 结构体只能整体初始化，不能被整体赋值 结构体内存对齐为什么要有结构体内存对齐?平台原因不是所有的硬件都能随意的访问任意地址处的任意数据，有的CPU只能从内存上地址为4的倍数的地址处读取数据，而为了可以读取结构体数据，结构体的起始位置的地址理所应当的为4的倍数，而在结构体内部维护内存对齐是为了迎合硬件的这一特性 性能原因因为为了CPU能够快速访问，提高访问效率，变量的起始地址应该具有这些特性，这就是所谓的”对齐”。例如在32位平台上，CPU一个只可以读取出4字节的内容，且只可以在4的整数倍位置进行访问，而当结构体中存放一个int类型变量时，结构体的起始位置一定是4的倍数，此时若在结构体内部不维护内存对齐，则取出一个整型的4字节，若该int变量的偏移量为3，则就需要先读取偏移量为0向后的4个字节，将最后一个字节中属于int成员变量的数据保存下来，再读取偏移量为4向后的4字节，将前这4字节中属于int成员变量的前3字节的数据再次保存，之后将这两段数据进行拼接，才能得到完整的int成员变量 结构体内存对齐规则 第一个成员在与结构体变量偏移量为0的地址处 当程序要存储一个结构体时，会在内存上的某一个地址处开始存储这个结构体，这时不论这个结构体的第一个成员是什么，都要从该地址的0偏移量处开始存储 其他成员变量要对齐到某个数字（对齐数）的整数倍的偏移量的地址处。对齐数 = 编译器的默认的对齐数与该成员大小的较小值 对齐数 = 编译器默认对齐数 &lt; 成员大小 ? 编译器默认对齐数 : 成员大小。 这里使用例子来帮助理解: ​ 假如第一个成员使用了1个字节的内存，这时按照道理应该就从偏移量为1的地方开始存放第一个成员（假设第二个成员大小为4），但是编译器并不是这样的，编译器先计算出对于第二个成员变量的对齐数（vs默认对齐数为8，Linux默认对齐数为4）为4，检测到偏移量为1，但1并不是4的整数倍，那么就要继续向后找，直到找到偏移量为4，偏移量为4恰好是4的整数倍，那么就可以从偏移量为4的位置开始存储第二个成员变量了。 ​ 这时紧接着又要存放第三个成员变量（假设第三个成员变量的大小为1），这时候编译器先要计算出属于第三个成员变量的默认对齐数为1，接下来编译器就来看看下一个位置的偏移量符不符合要求，下一个位置的偏移量为9，9是1的整数倍，所以第三个成员变量就从偏移量为9的位置开始存放了 Linux默认偏移量为4 vs默认对齐数是8 结构体的总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍 当编译器将结构体的成员数据都存储完成之后，接下来就会计算出这些成员变量中的最大对齐数（在本例中为4），得知最大的对齐数为4，编译器就会查看当前结构体的总大小，发现当前结构体的总大小为9，9并不是4的整数倍，那么编译器就继续占用空间，占到12时就会停止，因为12是4的整数倍 如果结构体内部嵌套了别的结构体，嵌套结构体的对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的所有成员的对齐数）的整数倍 也就是说，当一个结构体内嵌套了另外一个结构体时，被嵌套的结构体成员变量存放完成时要计算最大对齐数只需要从自己的成员变量对齐数中选出最大的即可，但是外部的结构体成员变量存放完成之后计算最大结构体时，要从自己的成员变量的对齐数和嵌套的结构提的成员变量的对齐数中挑选出一个最大的对齐数。 编译器存储一个结构体的过程当一个结构体要存储在内存中时，编译器会做如下的事情： 首先一个结构体要存储到内存中时，编译器首先会分配一个地址，作为该结构体的起始位置 编译器先拿到结构体的第一个成员变量，直接从相对起始位置0偏移量的位置开始存放第一个成员变量 第N（N = 1，2，3，…）成员变量存放完成之后，编译器又拿到第N + 1成员变量，此时编译器就要计算第N + 1个成员变量的大小（用来计算该成员变量的对齐数），使用该成员变量的大小与编译器的默认对齐数比较，较小的即就是该成员变量的对齐数，拿到对齐数之后，检测当前的偏移量是否为对齐数的整数倍。 如果是，编译器从当前偏移量位置开始存放第N + 1个成员变量 如果不是，编译器向后偏移（占用空间），直到偏移量为该成员变量对齐数的整数倍之后，开始从当前偏移量位置存放第N + 1个成员变量 当所有的结构体成员存放完成之后，编译器会回想出成员变量中最大的对齐数，之后检测当前结构体大小是否为最大对齐数的整数倍。 如果是，则结构体存放全部完成 如果不是，编译器继续向后偏移（占用空间），直到当前结构体大小为最大对齐数的整数倍，则结构体存放全部完成 查看结构体中变量相对起始位置的偏移量123456#include &lt;stddef.h&gt;size_t offsetof(type,member);//源码#define offsetof(s, m)(size_t)&amp;(((s*)0)-&gt;m) 参数 type：结构体类型 member：结构体的成员 返回值 结构体成员相对与结构体起始位置的偏移量 改变结构体的默认对齐数1#pragma pack(N) 使用N来改变编译器的默认对齐数为N 1#pragma pack() 恢复编译器的默认对齐数 位段位段不跨平台 位段与结构体的区别 位段的成员必须是int,usigned int,signed int 位段的成员名之后必须要有一个冒号和一个数字 位段的例子1234567struct A&#123; int a:2;//a成员只需要2个比特位 int b:4;//b成员只需要4个比特位 int c:8;//c成员只需要8个比特位 int d:20;//d成员需要20个比特位&#125;; 位段存放成员的方式不同的编译器存放位段的方式是不同的，所以位段是不跨平台的。但主要有以下两种方式，这里使用一个简单的位段来描述这个问题 1234567struct A&#123; int a:2; int b:8; int c:10; int d:30;&#125;; 编译器先开辟一个（int）4字节用来存放位段，位段的第一个成员使用2个比特位，则编译器将开辟好的字节的前两个比特位分配给第一个成员，此时还是=剩下30个比特位，第二个成员需要8个比特位，则编译器又分配了8个比特位给第二个成员，此时还剩下22个比特位，第三个成员需要10个比特位，则编译器又分配10个比特位给第三个成员，此时开辟好的空间只剩下12个比特位，但此时第四个成员需要30个比特位，在此时不同的编译器就会有不同的处理方式: 一种编译器会直接浪费掉剩下的12个字节，为第四个成员重新开辟一个(int)4字节的内存来存放 零一种编译器会将第四个成员变量的前12个字节存进剩下的空间中，为剩余的成员重新开辟内存存放 位段存在的问题 不可移植性，位段在不同的系统中会出现不同的结果 int位段被当作有符号数还是无符号数是不可预计的 位段中最大位的数目是不确定的 位段中的成员在内存中从左向右分配，还是从右向左分配是没有经过定义的 联合体（共用体）联合体也是一种特殊的自定义类型，这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块内存空间 联合体的内存分配规则 联合体分配的大小位成员变量中最大的成员大小 联合体的总大小必须是联合体成员中最大对齐数的整数倍 联合体的特性判断机器的大小端存储]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态多态的概念多态的概念: 通俗来说,就是多种形态，具体点就是完成某个行为，当不同的对象去完成时会产生不同的状态 多态的定义及实现多态定义的构成条件多态是在不同继承关系的类对象，去调用同一函数，产生了不同行为，比如Student继承了Person。Person对象买票全价，Student对象买票半价。 那么在继承重要构成多态还有两个条件: 调用函数的对象必须是指针或者引用 被调用的函数必须是虚函数，且完成了虚函数的重写 什么是虚函数虚函数: 就是在类的成员函数前面加virtual关键字 12345678class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票,全价" &lt;&lt;endl; &#125;&#125;; 什么是虚函数的重写虚函数的重写：派生类中有一个跟基类的完全相同的虚函数，我们就称子类的虚函数重写了基类的虚函数，完全相同是指: 函数名、参数、返回值都相同，另外虚函数的重写也叫作虚函数的覆盖。 12345678910111213141516171819202122232425262728293031class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票，全价" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票,半价" &lt;&lt; endl; &#125;&#125;void Func(Person&amp; p)&#123; p.BuyTicket();&#125;int main()&#123; Person ps; Student st; Func(ps); Func(st); return 0;&#125; 虚函数重写的例外：协变虚函数重写有一个例外：重写的虚函数的返回值可以不同，但是必须分别是基类指针和派生类指针或者基类引用和派生类引用。 1234567891011121314151617181920class A&#123;&#125;;class B : public A&#123;&#125;;class Person&#123;public: virtual A* f() &#123; return new A; &#125;&#125;;class Student : public Person&#123;public: virtual B* f() &#123; return new B; &#125;&#125;; 不规范的重写行为在派生类中重写的成员函数可以不加virtual关键字，也是构成重写的，因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性，我们只是重写了它。但是这是非常不规范的。 12345678910111213141516class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票 全价" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: void BuyTicket() &#123; cout &lt;&lt; "买票 半价" &lt;&lt; endl; &#125;&#125;; 析构函数的重写问题基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里它们的函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor,这也说明的基类的析构函数最好写成虚函数 12345678910111213141516171819202122232425262728class Person&#123;public: virtual ~Person() &#123; cout &lt;&lt; "~Person()" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: virtual ~Student() &#123; cout &lt;&lt; "~Student()" &lt;&lt; endl; &#125;&#125;;//只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成多态，才能保证p1和p2指向的对象正确的调用析构函数int main()&#123; Person* p1 = new Person; Person* p2 = new Student; delete p1; delete p2; return 0;&#125; 接口继承和实现继承普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现，虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口，所以如果不实现多态，不要把函数定义为虚函数。 重载、覆盖（重写）、隐藏（重定义）的对比 重载：两个函数在同一作用域,函数名相同、参数不同 重写(覆盖): 两个函数分别在基类和派生类的作用域，函数名/参数/返回值都必须相同(协变例外)，两个函数必须是虚函数 重定义(隐藏)：两个函数分别在基类和派生类的作用域，函数名相同，两个基类和派生类的同名函数不构成重写就是重定义 抽象类在虚函数的后面写上 = 0, 则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫做接口类），抽象类不能实例化对象。派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Car&#123;public: virtual void Drive() = 0;&#125;;class Benz : public Car&#123;public: virtual void Drive() &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125;&#125;;class BMW : public Car&#123;public: virtual void Drive() &#123; cout &lt;&lt; "BMW-操控" &lt;&lt; endl; &#125;&#125;;void Test()&#123; Car* pBenz = new Benz; pBenz-&gt;Drive(); Car* pBMW = new BMW; pBMW-&gt;Drive();&#125;class Car&#123;public: virtual void Drive()&#123;&#125;&#125;;//2.override 修饰派生类虚函数强制完成重写class Benz : public Car&#123;public: virtual void Drive()override &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125;&#125;; C++11 override和final另外补充一下的是C++11提供override和final来修饰虚函数 实际中我们建议多使用纯虚函数+override的方式来强制重写虚函数，因为虚函数的意义就是实现多态，如果没有重写，虚函数就没有意义 12345678910111213141516171819202122232425262728293031323334//1.final修饰基类的虚函数不能被派生类重写class Car&#123;public: virtual void Drive()final&#123;&#125;&#125;;class Benz : public Car&#123;public: virtual void Drive() &#123; virtual void Drive() &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125; &#125;&#125;;class Car&#123;public: virtual void Drive() &#123;&#125;&#125;;//2.override 修饰派生类虚函数强制完成重写，如果没有重写会编译报错class Benz : public Car&#123;public: virtual void Drive()override &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125;&#125;; 多态的原理1234567891011class Base&#123;public: virtual void Func1() &#123; cout &lt;&lt; "Func()" &lt;&lt; endl; &#125; private: int _b = 1;&#125;; 通过观察测试我们发现b对象是8bytes，除了_b成员，还多一个_vfptr放在对象的前面(注意有些平台可能会放到对象的后面，这个跟平台有关)，对象中的这个指针我们叫做虚函数表指针(v代表virtual,f代表function)，一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，虚函数表也简称虚表，那么派生类中为什么要放这个表呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int main()&#123; Base b; return 0;&#125;//针对上面的代码我们做出以下改造//1.我们增加一个派生类Derive去继承Base//2.Derive中重写Func1//3.Base再增加一个虚函数Func2和一个普通函数Func1class Base&#123;public: virtual void Func1() &#123; cout &lt;&lt; "Base::Func1()" &lt;&lt; endl; &#125; virtual void Func2() &#123; cout &lt;&lt; "Base::Func2()" &lt;&lt; endl; &#125; void Func3() &#123; cout &lt;&lt; "Base::Func3()" &lt;&lt; endl; &#125; private: int _b = 1;&#125;;class Derive : public Base&#123;public: virtual void Func1() &#123; cout &lt;&lt; "Derive::Func1()" &lt;&lt; endl; &#125;private: int _d = 2;&#125;;int main()&#123; Base b; Derive d; return 0;&#125; 通过观察和测试，我们发现了以下问题： 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以虚函数的重写叫做覆盖，覆盖就是指虚表中虚函数的覆盖，重写是语法的叫法，覆盖是原理层的叫法 另外Func继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr 总结一下派生类的虚表生成: a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚标的最后 这里还有一个很容易混淆的问题：虚函数存在哪的?虚表存在哪的？答：虚函数存在虚表，虚表存在对象中，注意上面的回答是错误的。但是很多童鞋都是这样深以为然的。注意虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。那么虚表存在哪的呢？实际我们去验证一下会发现vs下是存在代码段的 多态的原理123456789101112131415161718192021222324252627282930313233class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票-全价" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票-半价" &lt;&lt; endl; &#125;&#125;;void Func(Person&amp; p)&#123; p.BuyTicket();&#125;int main()&#123; Person Mike; Func(Mike); Student Johnson; Func(Johnson); return 0;&#125; 11. 观察下面的红色箭头我们看到，p是指向mike对象时，p-&gt;BuyTicket在mike的虚表中找到虚函数是Person::BuyTicket 观察下图的蓝色箭头我们看到，p是指向johnson对象时，p-&gt;BuyTicket在johnson的虚表中找到虚函数是Student -&gt; BuyTicket. 这样就实现出不同对象去完成同一行为时，展现出不同形态 反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是对象的指针或引用调用虚函数 满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象中去找的，不满足多态的函数调用时编译时确认好的 12345678910111213void Func(Person* p)&#123; p-&gt;BuyTicket();&#125;int main()&#123; Person mike; Func(&amp;mike); mike.BuyTicket(); return 0;&#125; 动态绑定与静态绑定 静态绑定又称为前期绑定(早绑定),在程序编译期间确定了程序的行为，也称为静态多态，比如:函数重载 动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构]]></title>
    <url>%2F2019%2F04%2F27%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Linux目录结构和作用【常见目录说明】 目录 /bin 存放二进制可执行文件(ls,cat,mkdir等),常用命令一般都在这里 /etc 存放系统管理和配置文件 /home 存放所有用户文件的根目录 /usr 用于存放系统应用程序，比较重要的目录/usr/local本地系统管理员软件安装目录(安装系统级的应用)。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序/usr/sbin 超级用户的一些管理程序/usr/doc Linux文档/usr/include linux下开发和编译应用程序所需要的头文件/usr/lib 常用的动态链接库和软件包的配置文件/usr/man 帮助文档/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里/usr/local/bin 本地增加的命令/usr/local/lib 本地增加的库 /opt 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里 /proc 虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息 /root 超级用户(系统管理员)的主目录 /sbin 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序，如ifconfig等 /dev 用于存放设备文件 /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他文件系统 /boot 存放用于系统引导时使用的各种文件 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件 /tmp 用于存放各种临时文件，是公用的临时文件存储点 /var 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件(系统启动日志等) /lost+found 这个目录平时是空的，系统非正常关机而留下”无家可归”的文件在这里 Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图： 通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大多数文件都不需要经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。 etc文件系统/etc目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的man页。许多网络配置文件也在/etc中。 /etc/rc或/etc/rc.d或/etc/rc?.d启动、或改变运行级时运行的脚本或脚本的目录 /etc/passwd用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其他信息。 /etc/fdprm软盘参数表，用以说明不同的软盘格式。可用setfdprm进行设置。更多的信息见setfdprm /etc/fstab指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。 /etc/group类似/etc/passwd,但说明的不是用户信息而是组的信息。包括组的各种数据 /etc/inittabinit的配置文件 /etc/issue包括用户再登陆提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定 /etc/magic“file”的配置文件。包含不同文件格式的说明，”file”基于它猜测文件类型 /etc/motdmotd是message of the day的缩写，用户成功登录后自动输出，内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等 /etc/mtab当前安装的文件系统列表。由脚本(script)初始化，并由mount命令自动更新，当需要一个当前安装的文件系统的列表时使用(例如df命令) /etc/shadow在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困难，以此增加系统的安全性 /etc/login.defslogin命令的配置文件 /etc/printcap类似/etc/termcap,但针对打印机。语法不同 /etc/profile、/etc/csh.login、/etc/csh.cshrc登陆或启动时bourne或c.shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境 /etc/securetty确认安全终端，即哪个终端允许超级用户(root)登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权 /etc/shells列出可以使用的shell。chsh命令允许用户在本文件指定范围内改变登录的shell。提供一台机器ftp服务的服务进程ftpd检查用户shell是否列在/etc/shells文件中，如果不是，将不允许该用户登录 /etc/termcap终端性能数据库。说明不同的终端用什么”转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。 /dev文件系统/dev目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。设备文件在安装时由系统产生，以后可以用/dev/makedev描述。/dev/makedev.local是系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准makedev的一部分)。下面简要介绍/dev下一些常用文件。 /dev/console系统控制台，也就是直接和系统连接的监视器 /dev/hdide硬盘驱动程序接口。如:/dev/hda指的是第一个硬盘，had1则是指/dev/hda的第一个分区。如系统中有其他的硬盘，则依次为/dev/hdb、/dev/hdc、……;如有多个分区依次为hda1、hda2…… /dev/sdscsi硬盘驱动程序接口，如有系统有scsi硬盘，就不会访问/dev/hah,而会访问/dev/sda。 /dev/fd软驱设备驱动程序。如：/dev/fd0指系统的第一个软盘，也就是通常所说的a:盘，/dev/fd1指第二个软盘，……而/dev/fd1h1440则表示访问驱动器1中的4，5高密盘。 /dev/stscsi磁带驱动器驱动程序 /dev/tty提供虚拟控制台支持。如：/dev/tty1指的是系统的第一个虚拟控制台，/dev/tty2则是系统的第二个虚拟控制台 /dev/pty提供远程登录伪终端支持。在进行telnet登陆时需要用到 /dev/ttys计算机串行接口，对于dos来说就是”com1”口 /dev/cua计算机串行接口，与调制控制器一起食用的设备 /dev/null“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/dev/null中即可 /usr文件系统/usr是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr里的所有文件一般来自linux发行版(distribution)；本地安装的程序和其他东西在/usr/local下，因为这样可以在升级新版或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。 /usr/x11r6包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x win d o w系统感到束手无策了。 /usr/bin集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin或/usr/local/bin中 /usr/sbin包括了根文件系统不必要的系统管理命令，例如多数服务程序 /usr/include包含了c语言的头文件，这些文件多以.h结尾。用来表述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib下，但习惯上一直沿用了这个名字 /usr/lib包含了程序或子系统的不变的数据文件，包含一些site-wide配置文件。名字lib来源于库(library);编程的原始库也存在/usr/lib里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中 /usr/local本地安装的软件和其他文件放在这里。这与/usr很相似。用户可能会在这发现一些比较大的软件包，如tex、emacs等。 /var文件系统/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/ v a r目录中有些内容是在/ u s r中的，但为了保持/ u s r目录的相对稳定，就把那些需要经常改变的目录放到/ v a r中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。 /var/catman包括了格式化过的帮助(man)页。帮助页的源文件一般存在/usr/man/man中；有些man页可能有预格式化的版本，存在/usr/man/cat中。而其他的man页在第一次看时都需要格式化，格式化完的版本存在/var/man中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman经常被清除，就像清除临时目录一样) /var/lib存放系统正常运行时要改变的文件 /var/local存放/usr/local中安装的程序的可变数据(即系统管理员安装的程序)。注意：如果必要，即使本地安装的程序也会使用其他/var目录，例如/var/lock /var/lock锁定文件。许多程序遵循在/var/lock中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。 /var/log各种程序的日志(log)文件，尤其是login(/var/log/wtmp log记录所有到系统的登录和注销)和syslog(/var/log/message记录存储所有核心和系统程序信息)。/var/log里的文件经常不确定地增长，应该定期清除。 /var/run保存在下一次系统引导前有效的关于系统的信息文件。例如，/var/run/utmp包含当前登录的用户的信息 /var/tmp比/tmp允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp有很久的文件 /proc文件系统/proc文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系统的信息。 /proc/x关于进程x的信息目录，这里x是这一进程的标识号。每个进程在/proc下有一个名为自己进程号的目录 /proc/cpuinfo存放处理器(cpu)的信息，如cpu的类型、制造商、型号和性能等。 /proc/devices当前运行的核心配置的设备驱动的列表 /proc/dma显示当前使用的dma通道 /proc/filesystems核心配置的文件系统信息 /proc/interrupts显示被占用的中断信息和占用者的信息，以及被占用的数量 /proc/ioports当前使用的i/o接口 /proc/ksyms核心符号表 /proc/net网络协议状态信息 /proc/uptime系统启动的时间长度 /proc/version核心版本]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的概念及定义]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[继承的概念及定义继承的概念继承机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用 123456789101112131415161718192021222324252627282930313233343536class Person&#123;public: void Print() &#123; cout &lt;&lt; "name:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "age:" &lt;&lt; _age &lt;&lt; endl; &#125; protected: string _name = "Peter"; //姓名 int _age = 18; //年龄&#125;;//继承父类的Person的成员(成员函数+成员变量)都会变成子类的一部分，这里体现出了Student和Teacher复用了Person的成员，下面我们使用监视窗口查看Student和Teacher对象，可以看到变量的复用，调用Print可以看到成员函数的复用class Student : public Person&#123;protected: int _stuid;//学号&#125;;class Teacher : public Person&#123;protected: int _jobid; //工号&#125;;int main()&#123; Student s; Teacher t; s.Print(); t.Print(); return 0;&#125; 继承的定义定义格式 如上述代码所示，Person是父类，也称作基类。Student是子类，也称作派生类，public为继承方式 继承关系和访问限定符 继承方式： public继承 protected继承 private继承 访问限定符 public访问 protected访问 private访问 继承基类成员访问方式的变化 类成员/继承方式 public继承 protected继承 private继承 基类的public成员 派生类的public成员 派生类的protected成员 派生类的private成员 基类的protected成员 派生类的protected成员 派生类的protected成员 派生类的private成员 基类的private成员 在派生类中不可见 在派生类中不可见 在派生类中不可见 总结 基类的private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它 基类private成员在派生类中是不能被访问的，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected，可以看出保护成员限定符是因继承才出现的 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见的，基类的其它成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。 使用关键字class默认的继承方式是private，使用struct时默认继承方式是public，不过最好显式的写出继承方式 在实际运用中一般使用都是public继承，几乎很少使用protected/private继承，也不提倡使用protected/private继承，因为protected/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强 123456789101112131415161718192021//实例演示三种继承关系下基类成员的各类型成员访问关系的变化class Person&#123;public: void Print() &#123; cout &lt;&lt; _name &lt;&lt; endl; &#125;private: string _name; //姓名private: int _age; //年龄&#125;;//class Student : protected Person//class Student : private Personclass Student : public Person&#123;protected: int _stunum;//学号&#125;; 基类和派生类对象赋值转换 派生类对象可以赋值给基类的对象/基类的指针/基类的引用。这里有个形象的说法叫做切片或者切割，寓意把派生类中父类那部分切来赋值过去。 基类对象不能赋值给派生类对象 基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic cast来进行识别后进行安全转换。 父类对象不能赋值给子类对象，可能会造成访问异常 父类指针在特定条件下可以赋值给子类指针。如果父类指针本身指向的为子类对象的空间，赋值是安全的，否则，不安全 1234567891011121314151617181920212223242526272829303132class Person&#123;protected: string _name; //姓名 string _sex; //性别 int _age; //年龄&#125;;class Student : public Person&#123;public: int _No; //学号&#125;;void Test()&#123; Student sobj; // 1.子类对象可以赋值给父类对象/指针/引用 Person pobj = sobj; Person* pp = &amp;obj; Person&amp; rp = sobj; // 2.基类对象不能赋值给派生类对象 sobj = pobj; // 3.基类的指针可以通过强制类型转换赋值给派生类的指针 pp = &amp;sobj; Student* ps1 = (Student*)pp; //这种情况转换是可以的 ps1-&gt;_No = 10; pp = &amp;pobj; Student* ps2 = (Student*)pp; //这种情况转换时虽然可以，但是会存在越界访问的问题 ps2-&gt;_No = 10;&#125; 继承中的作用域 在继承体系中基类和派生类都有独立的作用域 子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫做隐藏，也叫重定义。(在子类成员函数中，可以使用 基类::基类成员 显式访问) 需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏 注意在实际中在继承体系里面最好不要定义同名的成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//student的_num和Person的_num构成隐藏关系，可以看出这样代码虽然能跑，但是非常容易混淆class Person&#123;protected: string _name = "张三"; //姓名 int _num = 111; //身份证号&#125;;class Student : public Person&#123;public: void Print() &#123; cout &lt;&lt; "姓名：" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "身份证号:" &lt;&lt; Person::_num &lt;&lt; endl; cout &lt;&lt; "学号：" &lt;&lt; _num &lt;&lt; endl; &#125;protected: int _num = 999; //学号&#125;;void Test()&#123; Student s1; s1.Print();&#125;//B中的fun和A中的fun不是构成重载，因为不是在同一作用域//B中的fun和A中的fun构成隐藏，成员函数满足函数名相同就构成隐藏class A&#123;public: void fun() &#123; cout &lt;&lt; "fun()" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void fun(int i) &#123; A::fun(); cout &lt;&lt; "func(int i)-&gt;" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;void Test()&#123; B b; b.fun(10);&#125; 派生类的默认成员函数6个默认成员函数，”默认“的意思是指我们不写，编译器会帮我们自动生成一个，那么在派生类中，这几个成员函数是如何生成的？ 1. 构造函数函数： - 默认生成的：首先会自动调用父类的构造函数，再调用自己的构造函数 - 显式定义的：如果父类有默认构造函数，不需要显式调用，如果父类没有默认构造函数，需要在初始化列表当中显式调用 2. 拷贝构造函数： - 默认生成的：编译器会自动调用父类的拷贝构造函数 - 显式定义的：如果不显示调用父类的拷贝构造，编译器会调用父类的默认构造 3. 赋值运算符重载函数 - 默认生成的：编译器会自动调用父类的赋值运算符重载函数 - 显式定义的：如果不显式调用父类的赋值运算符重载函数，编译器不会调用父类的任何成员函数 4. 析构函数 - 默认生成的：先执行自己的析构函数，编译器再调用父类的析构函数 - 显式定义的：不需要显式调用父类的析构函数，编译器会自动调用，注意父类的析构函数和子类的析构函数会构成函数隐藏 5. 取地址运算符重载函数：使用编译器默认生成的即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Person&#123;public: Person(const char* name = "Peter") :_name(name) &#123; cout &lt;&lt; "Person()" &lt;&lt; endl; &#125; Person(const Person&amp; p) :_name(p._name) &#123; cout &lt;&lt; "Person(const Person&amp; p)" &lt;&lt; endl; &#125; Person&amp; operator=(const Person&amp; p) &#123; cout &lt;&lt; "Person operator=(const Person&amp; p)" &lt;&lt; endl; if(this != &amp;p) &#123; _name = p._name; &#125; return *this; &#125; ~Person() &#123; cout &lt;&lt; "~Person()" &lt;&lt; endl; &#125;protected: string _name; //姓名&#125;;class Student : public Person&#123;public: Student(const char* name, int num) :Person(name) ,_num(num) &#123; cout &lt;&lt; "Student()" &lt;&lt; endl; &#125; Student(const Student&amp; s) :Person(s) ,_num(s._num) &#123; cout &lt;&lt; "Student(const Student&amp; s)" &lt;&lt; endl; &#125; Student&amp; operator=(const Student&amp; s) &#123; cout &lt;&lt; "Student&amp; operator=(const Student&amp; s)" &lt;&lt; endl; if(this != &amp;s) &#123; Person::operator = (s); _num = s._num; &#125; return *this; &#125; ~Student() &#123; cout &lt;&lt; "~Student()" &lt;&lt; endl; &#125;protected: int _num; //学号&#125;;void Test()&#123; Student s1("jack", 18); Student s2(s1); Student s3("rose", 17); s1 = s3;&#125; 继承与友元友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 12345678910111213141516171819202122232425262728class Student;class Person&#123;public: friend void Display(const Person&amp; p, const Student&amp; s);protected: string _name; //姓名&#125;;class Student : public Person&#123;protected: int _stuNum; //学号&#125;;void Display(const Person&amp; p, const Student&amp; s)&#123; cout &lt;&lt; p._name &lt;&lt; endl; cout &lt;&lt; s._stuNum &lt;&lt; endl;&#125;void main()&#123; Person p; Student s; Display(p, s);&#125; 继承与静态成员基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例。 123456789101112131415161718192021222324252627282930313233343536class Person&#123;public: Person() &#123; ++_count; &#125;protected: string _name; //姓名public: static int _count; //统计人数&#125;;int Person :: _count = 0;class Student : public Person&#123;protected: int _stuNum; //学号&#125;;class Graduate : public Student&#123;protected: string _seminarCourse; //研究科目&#125;;void TestPerson()&#123; Student s1; Student s2; Student s3; Graduate s4; cout &lt;&lt; "人数:" &lt;&lt; Person :: _count &lt;&lt; endl; cout &lt;&lt; "人数:" &lt;&lt; Person :: _count &lt;&lt; endl;&#125; 复杂的菱形继承及菱形虚拟继承单继承：一个子类只有一个直接父类时称这个继承关系为单继承 多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承 菱形继承：菱形继承是多继承的一种特殊情况 菱形集成的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。在Assistant的对象中Person成员会有两份 123456789101112131415161718192021222324252627282930313233class Person&#123;public: string _name; //姓名&#125;;class Student : public Person&#123;protected: int _num; //学号&#125;;class Teacher : public Person&#123;protected: int _id; //职工编号&#125;;class Assistant : public Student,public Teacher&#123;protected: string _majorCourse; //主修课程&#125;;void Test()&#123; //这样会有二义性无法明确知道访问的是哪一个 Assistand a; a._name = "Peter"; //需要显式指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决 a.Student::_name = "xxx"; a.Teacher::_name = "yyy";&#125; 虚拟继承可以解决菱形继承的二义性和数据冗余的问题，如上面的继承关系，在Student和Teacher的继承Person时使用虚拟继承，即可解决问题。需要注意的是，虚拟继承不要在其他地方去使用 1234567891011121314151617181920212223242526272829class Person&#123;public: string _name; //姓名&#125;;class Student : virtual public Person&#123;protected: int _num; //学号&#125;;class Teacher : virtual public Person&#123;protected: int _id; //职工编号&#125;;class Assistant : public Student,public Teacher&#123;protected: string _majorCourse; //主修课程&#125;;void Test()&#123; Assistant a; a,_name = "Peter";&#125; 虚拟继承解决数据冗余和二义性的原理 12345678910111213141516171819202122232425262728293031323334353637class A&#123;public: int _a;&#125;;//class B : public Aclass B : virtual public A&#123;public: int _b;&#125;;//class C : public Aclass C : virtual public A&#123;public: int _c;&#125;;class D : public B, public C&#123;public: int _d;&#125;;int main()&#123; D d; d.B::_a = 1; d.C::_a = 2; d._b = 3; d._c = 4; d._d = 5; return 0;&#125; 继承的总结和反思 C++语法复杂，多继承就是一个体现，有了多继承,就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂，所以一般不建议设计出多继承，一定不要设计出菱形继承，否则在复杂度及性能上都有问题 多继承可以认为是C++的缺陷之一，后来很多语言都没有多继承，如java。 继承和组合 public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。 组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。 优先使用对象组合，而不是类继承 继承允许你根据基类的实现来定义派生类的实现，这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。”白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以”黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。 实际尽量多去用组合。组合的耦合度低，代码维护型好。不过继承也有用武之地的，有些关系适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。 123456789101112131415161718192021222324252627282930313233343536373839404142//Car和BMW Car和Benz构成is-a的关系class Car&#123;protected: string _colour = "白色"; //颜色 string _num = "陕A12345"; //车牌号&#125;;class BMW : public Car&#123;public: void Drive() &#123; cout &lt;&lt; "操控好" &lt;&lt; endl; &#125;&#125;;class Benz : public Car&#123;public: void Drive() &#123; cout &lt;&lt; "舒适" &lt;&lt; endl; &#125;&#125;;//Tire和Car构成has-a的关系class Tire&#123;protected: string _brand = "Michelin"; //品牌为米其林 size_t size = 19; //规格为19寸轮毂&#125;;class Car&#123;protected: string _colour = "白色"; //颜色 string _num = "陕A12345"; //车牌号 Tire _t; //轮胎&#125;;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux是什么及其常见指令]]></title>
    <url>%2F2019%2F04%2F22%2FLinux%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux是什么Linux是一个操作系统内核（操作系统 =&gt; 内核 + 一组配套的应用程序），而内核是用来负责对于软件资源和硬件设备的管理。 Linux发行版：CentOs,Android,Ubuntu,Debain,Kali,Mint …… Redhat(大部分公司中使用的发行版) Xshell:远程终端程序 Linux：全世界市场份额最高的操作系统，任何一名程序员都会用到的操作系统 1. 移动端领域（安卓） 2. 服务器领域（90%的服务器都用Linux） 3. 嵌入式领域 4. 桌面领域（Linux在桌面领域表现不佳） Linux下基本指令 ls指令 语法：ls 【选项】【目录或文件】 功能：对于目录，该命令列出该目录下的所有子目录与文件，对于文件，将列出文件名以及其他信息。 常用选项 -a 列出目录下的所有文件，包括以.开头的隐藏文件 -d 将目录像文件一样显示，而不是显示其下的文件。如：ls -d 指定目录 -i 输出文件的i节点的索引信息。如ls -ai 指定文件 -k 以k字节的形式表示文件的大小。ls -alk指定文件 -l 列出文件的详细信息 -n 用数字的UID,GID代替名称。 -F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字（socket）。（目录类型识别） -r 对目录反向排序 -t 以时间排序 -R 列出所有子目录下的文件。（递归） -1 一行只输出一个文件 pwd命令 语法：pwd 功能：显示用户当前所在的目录 cd指令 语法：cd 目录名 功能： 改变工作目录。将当前工作目录改变到指定的目录下 举例： cd .. ：返回上级目录 cd /home/hanhaodong/My_code/: 绝对路径 cd ../Linux/: 相对路径 (谈到相对路径，必须明确当前路径) cd~:进入用户的home目录 cd-：返回最近访问目录 touch指令 语法：touch [选项]… 文件… 功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的空文件。 常用选项 -a 或 –time=atime或–time=access或–time=use只更改存取时间 -c 或-no-create 不建立任何文档 -d 使用指定的日期时间，而非现在的时间 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题 -m 或–time=mtime或–time=modify 只更改变动时间 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同 -t 使用指定的日期时间，而非现在的时间 mkdir指令 语法：mkdir [选项] dirname 功能：在当前目录下创建一个名为”dirname”的目录 常用选项： -p,–parents 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录 rmdir指令&amp;&amp;rm指令 rmdir是一个与mkdir相对应的命令，mkdir是建立目录，而rmdir是删除命令 语法：rmdir [-p][dirName] 适用对象：具有当前目录操作仅限的所有使用者 功能：删除空目录 常用选项： -p 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除 rm命令可以同时删除文件或目录 语法： rm [-f -i -r -v][dirName/dir] 适用对象：所有使用者 功能：删除文件或目录 常用选项： -f 即使文件属性为只读(即写保护)，亦直接删除 -i 删除前逐一询问确认 -r 删除目录及其下所有文件 man指令（重要） Linux的命令有很多参数，我们可以通过查看联机手册获取帮助。访问Linux手册页的命令时man 语法：man [选项] 命令 常用选项： -k 根据关键字搜索联机帮助 num 只在第num章节找 -a 将所有章节的都显示出来，比如man printf 它缺省从第一章开始搜素，知道就停止，用a选项，当按下q退出，他会继续往后面搜索，直到所有章节都搜索完毕 man手册分为八章： 1. 是普通命令 2. 是系统调用，如open，write之类 3. 是库函数，如printf,fread4是特殊文件，也就是/dev下的各种设备文件 4. 是指文件的格式，比如passwd，就会说明这个文件中各个字段的含义 5. 是给游戏留用，由各个游戏自己定义 6. 是附件还有一些变量，比如像environ这种全局变量在这里就有说明 7. 是系统管理用的命令，这些命令只能由root使用，如ifconfig cp指令 语法： cp [选项] 原文件或目录 目标文件或目录 功能：复制文件或目录 说明：cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息 常用选项： -f 或 -force强行复制文件或目录，不论目的文件或目录是否已经存在 -i 或 -interactive 覆盖文件之前先询问用户 -r 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理 -R 或 -recursive递归处理，将指定目录下的文件及子目录一并处理 mv指令 mv命令是move的缩写，可以用来移动文件或者将文件改名(move (rename) files)，是Linux系统下常用的命令，经常用来备份文件或者目录 语法：mv [选项] 源文件或目录 目标文件或目录 功能： 视mv命令中第二个参数类型的不同(是目标文件还是目标目录)，mv命令将文件重命名或将其移至一个新的目录中 当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个(也可以是源目录名)，它将所给的源文件或目录重命名为给定的目标文件名 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中 常用选项 -f : force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i : 若目标文件(destination)已经存在时，就会询问是否覆盖！ cat 语法：cat [选项][文件] 功能：查看目标文件的内容 常用选项： -b 对非空输出行编号 -n 对输出的所有行编号 -s 不输出多行空行 less指令 less工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大 less的用法比起more更加的有弹性。在more的时候，我们并没有办法向前面翻，只能往后面看 但若使用了less时，就可以使用 [pageup][pagedown]等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容 除此之外，在less里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜 语法：less [参数] 文件 功能： less与more相似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件，而大部分编辑器都是直接把整个文件都加载(延时加载/懒加载) 选项： -i 忽略搜索时的大小写 -N 显示每行的行号 /字符串：向下搜索”字符串”的功能 ?字符串：向上搜索”字符串”的功能 n: 重复前一个搜索(与/或?有关) N：反向重复前一个搜索(与/或?有关) q:quit 时间相关的指令 date显示 date指定格式显示时间：date +%Y:%m:%d date用法：date [OPTION]…[+FORMAT] 在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下 %H: 小时(00…23) %M: 分钟(00…59) %S: 秒(00..61) %X: 相当于 %H:%M:%S %d: 日(01…31) %m: 月份(01…12) %Y: 完整年份(0000…9999) %F: 相当于 %Y-%m-%d 在设定时间方面 date -s //设置当前时间，只有root权限才能设置，其它只能查看 date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00 date -s 01:01:01 //设置具体时间，不会对日期做更改 date -s “01:01:01 2008-5-23” //这样可以设置全部时间 date -s “01:01:01 20080523” //这样可以设置全部时间 date -s “2008-5-23 01:01:01” //这样可以设置全部时间 date -s “20080523 01:01:01” //这样可以设置全部时间 时间戳 时间 -&gt; 时间戳: date +%s 时间戳 -&gt; 时间: date -d@1558749502 Unix时间戳(英文为Unix epoch,Unix time,POSIX time 或 Unix timestamp) 是从1970年1月1日(UTC/GMT的午夜)开始所经过的秒数，不考虑闰秒 find指令： -name Linux下find命令在目录结构中搜素文件，并执行指定的操作 Linux下find命令提供了相当多的查找条件，功能很强大，由于find具有强大的功能，所以它的选项也很多 即使系统中含有网络文件系统(NFS),find命令在该文件系统中同样有效，只要你具有相应的权限 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(指30G字节以上的文件系统) 语法：find pathname -options 功能：用于在文件树种查找文件，并作出相应的处理(可能访问磁盘) 常用选项： -name 按照文件名查找文件 grep指令 语法：grep [选项]搜寻字符串文件 功能：在文件中搜索字符串，将找到的行打印出来 常用选项： -i :忽略大小写的不同，所以大小写视为相同 -n：顺便输出行号 -v: 反向选择，亦即显示出没有’搜寻字符串’内容的那一行]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string类]]></title>
    <url>%2F2019%2F04%2F20%2Fstring%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[标准库中的string类 字符串是表示字符序列的类 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 string类是使用char（即作为它的字符类型，使用它的默认char_traits和分配器类型）。 string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数。 注意，这个类独立于所使用的编码来处理字节：如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。总结: string是表示字符串的字符串类 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作 string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char,char_traits,allocator&gt;string; 不能操作多字节或者变长字符的序列 在使用string类时，必须包含头文件以及using namespace std; string类的常用接口说明1. string类对象的常见构造 函数名称 功能说明 string() 构造空的string类对象，即空字符串 string(const char* s) 用C-string来构造string类对象 string(size_t n, char c) string类对象中包含n个字符c string(const string&amp; s) 拷贝构造函数 string(const string&amp; s, size_t n) 用s中的前n个字符构造新的string类对象 12345678void TestString()&#123; string s1; //构造空的string类对象s1 string s2(&quot;hello world&quot;); //用C格式字符串构造string类对象s2 string s3(10,&apos;a&apos;); //用10个字符&apos;a&apos;构造string类对象s3 string s4(s2); //拷贝构造s4 string s5(s3, 5); //用s3中前5个字符构造string对象s5&#125; 2. string类对象的容量操作 函数名称 功能说明 size_t size()const 返回字符串有效字符长度 size_t length()const 返回字符串有效字符长度 size_t capacity()const 返回空间总大小 bool empty()const 检测字符串是否为空串，是返回true,否则返回false void clear() 清空有效字符 void resize(size_t n,char c) 将有效字符的个数改成n个，多出的空间用字符c填充 void resize(size_t n) 将有效字符的个数改成n个，多出的空间用0填充 void reserve(size_t res_arg = 0) 为字符串预留空间 【注意】 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 clear()只是将string中有效字符清空,不改变底层空间大小。 reserve(size_t n)与resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时，reserve(n)用0来填充多出的元素空间，reserve(size_t n, char c)用字符c来填充多出的元素空间。注意: resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 reserve(size_t res, arg = 0): 为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小。 3.string类对象的访问操作 函数名称 功能说明 char&amp; operator 返回pos位置的字符，const string类对象调用 const char&amp; operator const 返回pos位置的字符，非const string类对象调用 1234567891011121314151617void TestString()&#123; String s1(&quot;hello world&quot;); const String s2(&quot;hello world&quot;); cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s1[0] &lt;&lt; &quot; &quot; &lt;&lt; s2[0] &lt;&lt; endl; s1[0] = &apos;H&apos;; cout &lt;&lt; s1 &lt;&lt; endl; for(size_t i = 0; i &lt; s1.size(); ++i) &#123; cout &lt;&lt; s1[i] &lt;&lt; endl; &#125; //s2[0] = &apos;h&apos;; 代码编译失败，因为const类型对象不能修改&#125; 4.string类对象的修改操作 函数名称 功能说明 void push_back(char c) 在字符串后尾插字符c string&amp; append(const char* s) 在字符串后追加一个字符串 string&amp; operator+=(const string&amp; str) 在字符串后追加字符串str string&amp; operator+=(char c) 在字符串后追加字符c const char* c_str()const 返回C格式字符串 size_t find(char c, size_t pos = 0) const 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置 size_t rfind(char c, size_t pos = npos) 从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置 string substr(size_t pos = 0, size_t n = npos) const 在str中从pos位置开始，截取n个字符，然后将其返回 【注意】 在string尾部追加字符时,s.push_back(a)/s.append(1,a)/s += ‘a’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预备好。 5.string类非成员函数 函数 功能说明 operator+ 尽量少用，因为效率低 operator&gt;&gt; 输入运算符重载 operator&lt;&lt; 输出运算符重载 getline 获取一行字符串 relational operators 大小比较]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数模板、类模板]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1.泛型编程怎样去实现一个通用的交换函数呢？ 12345678910111213141516171819202122void Swap(int&amp; left, int&amp; right)&#123; int temp = left; left = right; right = tmp;&#125;void Swap(double&amp; left, double&amp; right)&#123; double temp = left; left = right; right = temp;&#125;void Swap(char&amp; left, char&amp; right)&#123; char temp = left; left = right; right = temp;&#125;...... 使用函数重载虽然可以实现，但是有以下几个不好的地方 重载的函数仅仅只是类型不同，代码复用率较低，只要有新类型出现时，就需要增加时对应的函数 代码的可维护性比较低，一个出错可能所有的重载均出错 那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？ 泛型编程：编写与类型无关的通用代码，是代码复用的一种手段，模板是泛型编程的基础 2.函数模板2.1 函数模板概念函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本2.2 函数模板格式template返回值类型 函数名（参数列表）{} 1234567template&lt;typename T&gt;void Swap(T&amp; left, T&amp; right)&#123; T temp = left; left = right; right = temp;&#125; 注意：typename是用来定义模板参数的关键字，也可以使用class（切记，不能使用struct代替class）2.3 函数模板的原理模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具，所以其实模板就是将本来应该我们做的重复的事情交给了编译器在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用，比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。2.4 函数模板的实例化用不同类型的参数使用函数模板时，称为函数模板的实例化，模板参数实例化分为：隐式实例化和显式实例化 隐式实例化：让编译器根据实参推演模板参数的实际类型 123456789101112131415161718192021222324252627template&lt;class T&gt;T Add(const T&amp; left, const T&amp; right)&#123; return left + right;&#125;int main()&#123; int a1 = 10, a2 = 20; double d1 = 10.0, d2 = 20.0; Add(a1, a2); Add(d1, d2);/* Add(a1, d1); 该语句不能通过编译， 因为在编译期间， 当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参的d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int或者double类型而报错注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出现问题，编译器就需要背黑锅*///此时有两种处理方式：1.用户自己来强制转化 2.使用显式实例化 Add(a, (int)d); return 0;&#125; 显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型 123456789int main(void)&#123; int a = 10; double b = 20.0; //显式实例化 Add&lt;int&gt;(a, b); return 0;&#125; 如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。 2.5模板参数的匹配规则 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数 123456789101112131415161718//专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;//通用加法函数template&lt;class T&gt;T Add(T left, T right)&#123; return left + right;&#125;void Test()&#123; Add(1,2); //与非模板函数匹配，编译器不需要特化 Add&lt;int&gt;(1,2);//调用编译器特化的Add版本&#125; 对于非模板函数和同名函数模板，如果其他条件都相同，在调用时会优先调用非模板函数而不会从该模板产生出一个实例，如果模板可以产生一个具有良好匹配的函数，那么将选择模板 123456789101112131415161718//专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;//通用加法函数template&lt;class T1, class T2&gt;T1 Add(T1 left, T2 right)&#123; return left + right;&#125;void Test()&#123; Add(1, 2); //与非函数模板类型完全匹配，不需要函数模板实例化 Add(1, 2.0); //模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数&#125; 模板函数不允许自动类型转换，但普通函数可以进行自动类型转换3.类模板3.1 类模板的定义格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758template&lt;class T1,class T2,......,class Tn&gt;class 类模板名&#123; //类内容定义&#125;;//动态顺序表template&lt;class T&gt;class Vector&#123;public: Vector(size_t capacity = 10) :_pData(new T[capacity]) ,_size(0) ,_capacity(capacity) &#123;&#125; //使用析构函数演示，在类中声明，在类外定义。 ~Vector(); void PushBack(const T&amp; data) &#123; //_CheckCapacity(); _pData[_size++] = data; &#125; void PopBack() &#123; --_size; &#125; size_t Size() &#123; return _size; &#125; T&amp; operator[](size_t pos) &#123; assert(pos &lt; _size); return _pData[pos]; &#125; private: T* _pData; size_t _size; size_t _capacity;&#125;;//注意：类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;Vector&lt;T&gt;::~Vector()&#123; if(_pData) &#123; delete[] _pData; &#125;&#125; 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具 3.2类模板的实例化类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;,然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类 12345678910111213141516171819202122//Vector类名，Vector&lt;int&gt;才是类型Vector&lt;int&gt; s1;s1.PushBack(1);s1.PushBack(2);s1.PushBack(3);Vector&lt;double&gt; s2;s2.PushBack(1.0);s2.PushBack(2.0);s2.PushBack(3.0);for(size_t i = 0;i &lt; s1.size(); ++i)&#123; cout &lt;&lt; s1[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for(size_t i = 0; i &lt; s1.size() ; ++i)&#123; cout &lt;&lt; s2[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2F2019%2F04%2F18%2FC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.C/C++内存分布【说明】 栈又叫堆栈，非静态局部变量/函数参数/返回值等，栈是向下增长的。 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享内存，做进程间通信。 堆用于程序运行时动态内存分配，堆是可以向上增长的。 数据段-存储全局数据和静态数据。 代码段-可执行的代码/只读常量。2.C语言中动态内存管理方式2.1 malloc/calloc/realloc和free 12345678910void Test()&#123; int *p1 = (int*)malloc(sizeof(int)); free(p1); int* p2 = (int*)calloc(4, sizeof(int)); int* p3 = (int*)realloc(p2, sizeof(int)*10); free(p3);&#125; 3.C++内存管理方式C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式，通过new和delete操作符进行动态内存管理。3.1 new/delete 操作内置类型 12345678910111213141516void Test()&#123; //动态申请一个int类型的空间 int* ptr4 = new int; //动态申请一个int类型的空间并初始化为10 int* ptr5 = new int(10); //动态申请10个int类型的空间 int ptr6 = new int[10]; delete ptr4; delete ptr5; delete[] ptr6; //注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]&#125; 3.2 new和delete操作自定义类型 123456789101112131415161718192021222324252627class Test&#123;public: Test() :_data(0) &#123; cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl; &#125;private: int _data;&#125;;void Test()&#123; //申请单个Test类型的对象 Test* p1 = new Test; delete p1; //申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2;&#125; 【注意】：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc和free不会。 4. operator new与operator delete函数new和delete是用户进行动态内存申请和释放的操作符，operator new和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete底层通过operator delete全局函数来释放空间 1234567891011121314151617181920/*operator new: 该函数实际通过malloc来申请空间，当malloc&apos;申请空间成功时直接返回；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常*/void *_CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)&#123; //try to allocate size bytes void *p; while((p == malloc(size)) == 0) if(_callnewh(size) == 0) &#123; // report no memory //如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); &#125; return (p);&#125; operator new实际也是通过malloc来申请空间，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete最终是通过free来释放空间的 下面代码演示了，针对链表的节点ListNode通过重载类专属operator new/operator delete,实现链表节点使用内存池申请和释放内存，提高效率. 1234567891011121314151617181920struct LlistNode&#123; ListNode* _next; ListNode* _prev; int _data; void* operator new(size_t n) &#123; void* p = nullptr; p = allocator&lt;ListNode&gt;().allocate(1); cout &lt;&lt; &quot;memory pool allocate&quot; &lt;&lt; endl; return p; &#125; void operator delete(void* p) &#123; allocator&lt;ListNode&gt;().deallocate((ListNode*)p, 1); cout &lt;&lt; &quot;memory pool deallocate&quot; &lt;&lt; endl; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334class List&#123;public: List() &#123; _head = new ListNode; _head-&gt;next = _head; _head-&gt;prev = _head; &#125; ~List() &#123; ListNode* cur = _head-&gt;next; while(cur != _head) &#123; ListNode* next = cur-&gt;_next; delete cur; cur = next; &#125; delete _head; _head = nullptr; &#125;private: ListNode* _head;&#125;;int main()&#123; List l; return 0;&#125; 5.new和delete的实现原理5.1 内置类型如果申请的是内置类型空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时就会抛异常，malloc会返回NULL。5.2 自定义类型 new的原理 1. 调用operator new函数申请空间 2. 在申请的空间上执行构造函数，完成对象的构造 delete的原理 1. 在空间上执行析构函数，完成对象中的资源清理工作 2. 调用operator delete函数释放对象的空间 new T[N]的原理 1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请 2. 在申请的空间上执行N此构造函数 delete[]的原理 1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间 6. 内存泄漏6.1 什么是内存泄漏内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄露并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费 123456789101112void MemoryLeaks()&#123; // 1.内存申请了忘记释放 int *p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p2 = new int[10]; Func(); // 这里Func函数抛异常导致delete[] p3未执行，p3没有被释放 delete[] p3;&#125; 6.2 内存泄漏分类 堆内存泄漏（Heap leak） 堆内存指的是程序执行中依据须要分配通过malloc/calloc/realloc/new等从堆中分配的一块内存，用完后必须通过调用相应的free或delete删掉，加入程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生内存泄漏。 系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 6.3 如何避免内存泄漏 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps: 这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出现问题。需要下一条智能指针来管理才有保证。 采用RAII思想或者只能指针来管理资源。 有些公司内部规范使用内部实现的私有内存管理库，这套库自带内存泄漏检测的功能选项。 出问题了使用内存泄漏工具检测。ps: 不过很多工具都不够靠谱，或者收费昂贵。 【总结】内存泄漏非常常见，解决方案分为两种：1.事先预防型，如智能指针等。2.事后查错型。如泄漏检测工具。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解static、内部类、友元函数]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%90%86%E8%A7%A3static%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 再谈构造函数1.1 构造函数体赋值在创建对象时，编译器通过调用构造函数，给对象各个成员变量一个合适的初始值 123456789101112131415class Date&#123;public: Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; private: int _year; int _month; int _day;&#125;; 虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造函数体中的语句只能将其称作为赋初值，而不能称作初始化，因为初始化只能初始化一次，而构造函数体内可以多次赋值。 1.2 初始化列表初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个成员变量后面跟一个放在括号中的初始值或表达式 1234567891011121314class Date&#123;public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125;private: int _year; int _month; int _day;&#125;; 【注意】 1.每个成员变量在初始化列表中只能出现一次（初始化只能出现一次） 2.类中包含以下成员，必须放在初始化列表位置进行初始化： 引用成员变量 const成员变量 类类型成员变量（该类没有默认构造函数）12345678910111213141516171819202122class A&#123;public: A(int a) :_a(a) &#123;&#125;private: int _a;&#125;;class B&#123;public: B(int a, int ref) :_aobj(a) ,_ref(ref) ,_n(10) &#123;&#125;private: A _aobj; //没有默认构造函数 int&amp; ref; //引用 const int _n; //const&#125;; 尽量使用初始化列表初始化， 因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。 123456789101112131415161718192021222324252627class Time&#123;public: Time(int hour = 0) :_hour(hour) &#123; cout &lt;&lt; &quot;Time()&quot; &lt;&lt; endl; &#125;private: int _hour;&#125;;class Date&#123;public: Date(int day) &#123;&#125;private: int _day; Time _t;&#125;;int main()&#123; Date d(1);&#125; 4.成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关 1234567891011class Array&#123;public: Array(int size) :_size(size) ,_array((int*)malloc(sizeof(int)*_size)) &#123;&#125;private: int* _array; int _size;&#125; 1.3 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用 12345678910111213141516171819202122class Date&#123;public: Date(int year) :_year(year) &#123;&#125; explicit Date(int year) :_year(year) &#123;&#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1(2018); //用一个整型变量给日期类型对象赋值 //实际编译器背后会用2019构造一个无名对象， 最后用无名对象给d1对象进行赋值 d1 = 2019;&#125; 上述代码可读性不是很好，用explicit修是构造函数，将会禁止单参构造函数的隐式转换。 2.static成员2.1 概念声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量;用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化 面试题：实现一个类，计算程序中创建出了多少个类对象。 12345678910111213141516171819202122class A&#123;public: A() &#123;++_scount;&#125; A(const A&amp; t) &#123;++_scount;&#125; static int GetACount() &#123;return _scount;&#125;private: static int _scount;&#125;;int Test::_count = 0;void TestA()&#123; cout &lt;&lt; A::GetACount() &lt;&lt; endl; A a1, a2; A a3(a1); cout &lt;&lt; A:: GetACount() &lt;&lt; endl;&#125; 2.2 特性 1.静态成员为所有类对象所共享，不属于某个具体的实例 2.静态成员变量必须在类外定义，定义时不添加static关键字 3.类静态成员即可用类名::静态成员或者对象。静态成员来访问 4.静态成员函数没有隐藏的this指针，不能访问任何非静态成员 5.静态成员和类的普通成员一样，也是public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数。 3.C++的成员初始化新用法c++支持非静态成员变量在声明时，直接初始化 123456789101112131415161718192021222324252627282930313233343536class B&#123;public: B(int b = 0) :_b(b) &#123;&#125; int _b;&#125;;class A&#123;public: void Print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b._b &lt;&lt;endl; cout &lt;&lt; p &lt;&lt; endl; &#125;private: //非静态成员变量，可以在成员声明时，直接初始化 int a = 10; B b = 20; int* p = (int*)malloc(4); static int n; &#125;;int A::n = 10;int main()&#123; A a; a.Print(); return 0;&#125; 4.友元友元分为： 友元函数和友元类友元提供了一种突破封装的方式，有时提供了便利，但是友元会增加耦合度，破坏了封装，所以友元不宜多用。4.1 友元函数问题：现在我们尝试去重载operate&lt;&lt;，然后发现我们没办法将operate&lt;&lt;重载成成员函数。因为cout输出流对象和隐含的this指针抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。 1234567891011121314151617181920212223242526class Date&#123;public: Date(int year, int month,int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125; ostream&amp; operator&lt;&lt;(ostream&amp; _cout) &#123; _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d(2018, 12, 24); d &lt;&lt; cout; return 0;&#125; 友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。 12345678910111213141516171819202122232425262728293031323334353637class Date&#123;friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);friend istream&amp; operator&gt;&gt;(istream&amp; _cin,const Date&amp; d);public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125;private: int _year; int _month; int _day;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)&#123; _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout;&#125;istream&amp; operator&gt;&gt;(istream&amp; _cin, const Date&amp; d)&#123; _cin &gt;&gt; d._year; _cin &gt;&gt; d._month; _cin &gt;&gt; d._day; return _cin;&#125;int main()&#123; Date d; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 说明： 友元函数可以访问类的私有成员，但不是类的成员函数 友元函数不能用const修饰 友元函数可以在类定义的任何地方声明，不受访问限定符限制 一个函数可以是多个类的友元函数 友元函数的调用与普通函数的调用和原理相同 4.2 友元类友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员 友元函数是单向的，不具有交换性比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行 友元关系不能传递如果B是A的友元，C是B的友元，则不能说明C是A的友元 12345678910111213141516171819202122232425262728293031323334353637383940class Date; //前置声明class Time&#123; friend class Date; //声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量public: Time(int hour, int minute, int second) : _hour(hour) , _minute(minute) ,_second(second) &#123;&#125;private: int _hour; int _minute; int _second;&#125;;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1) : _year(year) , _month(month) , _day(day) &#123;&#125; void SetTimeOfDate(int hour, int minute, int second) &#123; //直接访问时间类私有的成员变量 _t._hour = hour; _t._minute = minute; _t._second = second; &#125;private: int _year; int _month; int _day; Time _t;&#125;; 5.内部类5.1 概念及特性概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类，外部类对内部类没有任何优越的访问权限。注意：内部类就是外部类的友元类。注意友元类的定义。内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。 特性： 内部类可以定义在外部类的public、projected、private都是可以的。 注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 sizeof(外部类) = 外部类，和内部类没有任何关系。 1234567891011121314151617181920212223242526class A&#123;private: static int k; int h;public: class B &#123; public: void foo(const A&amp; a) &#123; cout &lt;&lt; k &lt;&lt; endl; //OK cout &lt;&lt; a.h &lt;&lt; endl; //OK &#125; &#125;;&#125;;int A::k = 1;int main()&#123; A::B b; b.foo(A()); return 0;&#125; 6.再次理解封装c++是基于面向对象的程序，面向对象有三大特性即： 封装、继承、多态。 c++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起；通过访问限定符选择性的将其部分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让整个事情复杂化。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的六个默认成员函数如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并非如此，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。class Date {}; 1.构造函数·1.1 概念 构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。1.2 特性 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称是构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。 其特征如下： 1.函数名与类名相同 2.无返回值 3.对象实例化时编译器自动调用对应的构造函数 4.构造函数可以重载 12345678910111213141516171819202122232425262728class Date&#123;public: //1.无参构造函数 Date() &#123;&#125; //2.带参构造函数 Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1;//调用无参构造函数 Date d2(2015, 1, 1);//调用带参构造函数 //注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明 //以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象 Date d3();&#125; 5.如果类中没有显式定义构造函数，则c++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。6.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个，注意：无参构造函数，全缺省构造函数，我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。7.c++把类型分成内置类型（基本类型）和自定义类型。内置类型就是语法已经定义好的类型：如 int/char….，自定义类型就是我们使用class/struct/union自己定义的类型，编译器生成的默认构造函数会调用自定义类型的默认构造函数. 2.析构函数2.1 概念析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的，而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。2.2 特性析构是特殊的成员函数。特征如下：1.析构函数名是在类名前加上字符~2.无参数无返回值3.一个类有且只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数4.对象生命周期结束时，c++编译系统系统自动调用析构函数5.编译器生成的默认析构函数，对会自定类型成员调用它的析构函数 3.拷贝构造函数3.1 概念构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），再用已存在的类类型对象创建新对象时由编译器自动调用。3.2 特征1.拷贝构造函数是构造函数的一个重载形式2.拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式对引发无穷递归调用 12345678910111213141516171819202122232425262728class Date&#123; Date(int _year = 1900, int _month = 1,int _day = 1) &#123; _year = year; _month = month; _day = day; &#125; Date(const Date&amp; d) &#123; _year = d.year; _month = d.month; _day = d.day; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1; Date d2(d1); return 0;&#125; 3.若未显式定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝。 4.赋值运算符重载4.1 运算符重载c++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型operator操作符（参数列表）注意：1.不能通过连接其他符号来创建新的操作符：比如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，例如：内置的类型+，不能改变其含义。4.作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参5.、::、sizeof、？:、.注意以上五个运算符不能重载。5.2 赋值运算符重载赋值运算符主要有四点：1.参数类型2.返回值3.检测是否自己给自己赋值4.返回this5.一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝 6.const成员6.1 const修饰类的成员函数将const修饰的类的成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。6.2 有以下需要注意的点1.const对象不可以调用非const成员函数2.非const对象可以调用const成员函数3.const成员函数内不可以调用其他的非const成员函数4.非const成员函数内可以调用其它的const成员函数 7.取地址及const取地址操作符重载123456789101112131415161718这两个默认成员函数一般不用重新定义，编译器默认会生成class Date&#123;public: Date* operator&amp;() &#123; return this; &#125; const Date* operator&amp;()const &#123; return this; &#125; private: int _year; int _monthl int _day;&#125;; 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载比如想让别人获取到指定的内容！]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The_first_blog]]></title>
    <url>%2F2019%2F04%2F04%2FThe-first-blog%2F</url>
    <content type="text"><![CDATA[C++基础相关知识一.命名空间在c/c++中，变量、函数、类都是大量存在的，这些函数、变量和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或命名污染，namespace关键字的出现就是为了避免这种问题。 //1.普通的命名空间 namespace N1 //N1为命名空间的名称 { //命名空间的内容，可以定义变量，也可以定义函数 int a; int Add(int left , int right) { return left + right; } } //2.命名空间可以嵌套 namespace N2 { int a; int b; int Add(int left , int left) { return left + right; } namespace N3 { int c; int d; int sub( int left,int right ) { return left - right; } } } //3.同一个工程中允许存在多个相同名称的命名空间 // 编译器最终会合成同一个命名空间中 namespace N1 { int Mul(int left , int right) { return left*right; } } 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限与该命名空间中 二.c++输入&amp;输出12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello world!!&quot;&lt;&lt;endl; return 0;] 1.使用cout标准输出（控制台）和cin标准输入（键盘）时，必须包含头文件以及std标准命名空间。 注意：早期标准库将所有功能在全局域中实现，声明在.h后面的头文件中，使用时只需包含对应头文 件即可，后来将其实现在std命名空间下，为了和c头文件区分，也为了正确使用命名空间，规定 c++头文件不带.h;旧编译器（vc 6.0）中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐 使用+std的方式。 2.使用c++输入输出更方便，不需增加数据结构的控制。比如：整型-%d，字符-%c。 三. 缺省参数概念：缺省参数就是声明或定义时为函数的参数指定一个默认值。在调用函数时，如果没有指定实参则采用该默认值，否则使用指定实参。 12345678910void TestFunc(int a = 0)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;int main()&#123; TestFunc();//没有传参时，使用参数的默认值 TestFunc(10);//传参时使用指定实参&#125; 参数缺省分类全缺省参数: 123456void TestFunc(int a = 10,int b = 20, int c = 30)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 半缺省参数 1234567void TestFunc(int a, int b = 10,int c = 20)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 注意： 1.半缺省参数必须从右往左依次来给出，不能间隔着来给 2.缺省参数不能在函数声明和定义时同时出现。 123456//a.hvoid TestFunc(int a = 10);//a.cvoid TestFunc()int a = 20)&#123;&#125;//注意：如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用哪个缺省值 3.缺省值必须是常量或者全局变量4.C语言不支持（编译器不支持） 四.函数重载 函数重载的概念：是函数的的一种特殊情况，c++允许在同一作用域中声明几个功能相似的同名函数，这些同名函数的形参列表（参数个数或类型或顺序）必须不同，常用来处理或实现功能类似数据类型不同的问题。 123456789101112131415161718192021int Add(int left,int right)&#123; return left + right;&#125;double Add(double left, double right)&#123; return left + right;&#125;long Add(long left, long right)&#123; return left + right;&#125;int main()&#123; Add(10 , 20); Add(10.0 , 20.0); Add(10L , 20L)； return 0;&#125; extern “C”有时候在c++工程中可能需要将某些函数按照c的风格来编译，在函数前加extern “C”,意思是告诉编译器，将该函数按照C语言规则来编译。 1234567extern &quot;C&quot; int Add(int left, int right);int main()&#123; Add(1,2); return 0;&#125; 链接时报错：error LINK2019：无法解析的外部符号_Add，该符号在函数_main中被引用 引用引用概念：引用不是新定义一个变量，而是给已存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一快内存空间。类型&amp;引用变量名（对象名）= 引用实体 1234567void TestRef()&#123; int a = 10; int&amp; ra = a;//&lt;===定义引用类型 printf(&quot;%p&quot;,&amp;a); printf(&quot;%p&quot;,&amp;ra);&#125; 注意：引用类型必须和引用实体是同种类型。引用特性：1.引用在定义时必须初始化 2.一个变量可以有多个引用 3.引用一旦引用一个实体，再不能引用其他实体]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love You Forever]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Forever! Forever! Forever! How Deep Is Your Love 启窗以望，星瀚凌凌。望无路兮，无以所归。 昔既难忆，企留我心。抬首对穹，平嗓来歌。 裹卷相思，寄我爱人。孤孑一身。泪染两襟。 此出一曲，银河往替。凝眸流火，遥寄千里。 所落之处，记为老故。所思之疆，亦已焉哉。 没于黑弥，不得所终。凝空对唱，此歌凄哀。 告我所爱，知我所爱，可得故思，于此起风。 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
