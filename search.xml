<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++类型转换]]></title>
    <url>%2F2019%2F07%2F26%2FC-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[C++的类型转换C语言中的类型转换123456789101112void test()&#123; int i = 1; //隐式类型转换 double d = 1; printf("%d, %.2f\n", i, d); int *p = &amp;i; //显示的强制类型转换 int address = (int)p; printf("%x, %d\n", p, address);&#125; 缺陷：转换的可视性比较差，所有的转换形式都是以一种相同形式书写，难以跟踪错误的转换 C++强制类型转换 标准C++为了加强类型转换的可能性，引入了四种命名的强制类型转换操作符： static_cast、reinterpret_cast、const_cast、dynamic_cast static_cast static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用static_cast，但它不能用于两个不相关的类型进行转换 123456int main()&#123; double d = 12.34; int a = static_cast&lt;int&gt;(d); cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; reinterpret_cast reinterpret_cast操作符通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型 12345678910111213typedef void (*FUNC)();int DoSomething(int i)&#123; cout &lt;&lt; "DoSomething" &lt;&lt; endl; return 0;&#125;void Test()&#123; //reinterpret_cast可以编译器以FUNC的定义方式去看待DoSomething函数 //所以非常的BUG，下面转换函数指针的代码是不可移植的，所以不建议这样用 //C++不保证所有的函数指针都被一样的使用，所以这样用有时会产生不确定的结果 FUNC F = reinterpret_cast&lt;FUNC&gt;(DoSomething); f();&#125; const_cast const_cast最常用的用途就是删除变量的const属性，方便赋值 1234567void Test()&#123; const int a = 2; int* p = const_cast&lt;int*&gt;(&amp;a); *p = 3; cout &lt;&lt; a &lt;&lt; endl;&#125; dynamic_cast dynamic_cast用于将一个父类对象的指针转换为子类对象的指针或者引用（动态转换） 向上转型：子类对象指针-&gt;父类指针/引用（不需要转换，赋值兼容规则） 向下转型：父类对象指针-&gt;子类指针/引用（用dynamic_cast转型是安全的） 注意：1.dynamic_cast只能用于含有虚函数的类 ​ 2.dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0 1234567891011121314151617181920212223class A&#123;public: virtual void f()&#123;&#125;&#125;;class B : public A&#123;&#125;;void fun(A* pa)&#123; //dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回 B* pb1 = static_cast&lt;B*&gt;(pa); B* pb2 = dynamic_cast&lt;B*&gt;(pa); cout &lt;&lt; "pb1:" &lt;&lt; pb1 &lt;&lt; endl; cout &lt;&lt; "pb2:" &lt;&lt; pb2 &lt;&lt; endl;&#125;int main()&#123; A a; B b; fun(&amp;a); fun(%b); return 0;&#125; 注意：强制类型转换关闭或挂起了正常的类型检查。每次使用强制类型转换前，应该仔细考虑是否还有其他不同的方法达到同一目的，如果非强制类型转换不可，则应限制强制转换值的作用域，以减少发生错误的机会。建议：避免使用强制类型转换 explicit explicit关键字阻止经过转换构造函数进行的隐式转换的发生 12345678910111213141516171819class A&#123;public: explicit A(int a)&#123; cout &lt;&lt; "A(int a)" &lt;&lt; endl; &#125; A(const A&amp; a)&#123; cout &lt;&lt; "A(const A&amp; a)" &lt;&lt; endl; &#125;private: int _a;&#125;;int main()&#123; A a1(1); //隐式转换-&gt; A tmp(1); A a2(tmp); A a2 = 1;&#125; 为什么C++需要四种类型转换 C风格的转换格式很简单，但是有不少缺点的： 隐式类型转化有些情况下可能会出问题 显式类型转换将所有情况混合在一起，代码不够清晰 RTTI RTTI：Run-time Type identificatiion的简称，即：运行时类型识别。 C++通过以下方式来支持RTTI typeid运算符 dynamic_cast运算符]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解TCP的三次握手与四次挥手]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%90%86%E8%A7%A3TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP的三次握手与四次挥手TCP协议段格式 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 确认ACK：占1位，仅当ACK = 1时，确认号字段才有效。ACK = 0时，确认号无效。 同步SYN：连接建立时用于同步序号。当SYN = 1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。 终止FIN：用来释放一个连接。FIN = 1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序列号。 字段 含义 URG 紧急指针是否有效。为1，表示某一位需要被优先处理 ACK 确认号是否有效，一般置为1. PSH 显示接收端应用程序立即从TCP缓冲区把数据读走 RST 对方要求重新建立连接，复位 SYN 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 FIN 希望断开连接 源/目的端口号：表示数据是从哪个进程来，到哪个进程去； 32位序号/32位确认号 4位TCP报文长度：表示该TCP头部有多少个bit（有多少个4字节）；所以TCP头部最大长度是4 * 15 = 60 4位标志位 URG：紧急指针是否有效 ACK：确认号是否有效 PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走 RST：对方要求重新建立连接；我们把携带RST标识的称为复位报文段 SYN：请求建立连接；我们把携带SYN标识的称为同步报文段 FIN：通知对方，本端要关闭了，我们称携带FIN标识的成为结束报文段 16为校验和：发送端填充，CRC校验，接收端校验不通过，则认为数据有问题，此处的校验和不光包含TCP首部，也包含TCP数据部分 16位紧急指针：标识哪部分数据是紧急数据 40字节头部选项：暂时忽略 三次握手过程理解 第一次握手：建立连接时，客户端发送syn包（syn = j）到服务器，并进入SYN_SENT状态，等待服务器确认时；SYN：同步序列号编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack = j + 1），同时自己也发送一个SYN包（syn = k），即SYN + ACK包，此时服务器进入SYN_RECV状态。 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack = k + 1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 超时重传机制 主机A发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B 如果主机A在一个特定时间间隔内没有收到B发来的确认应答，就会进行重发 但是，客户端未收到服务器发来的确认应答，也可能是因为ACK丢失了 因此服务器会收到很多重复数据，那么TCP协议需要能够识别出哪些包是重复的包。并且把重复的丢弃掉，这时候我们可以利用前面提到的序列号，就可以很容易做到去重的效果 那么如果超时，超时的时间如何确定的？ 最理想的情况下，找到一个最小的时间，保证“确认应答一定能在这个时间内返回“ 但是这个时间的长短，随着网络环境的不同，是有差异的 如果超时时间设的太长，会影响整体的重传效率 如果超时时间设的太短，有可能会频繁发送重复的包 TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间 Linux中(BSD Unix和Windows也是如此)，超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍 如果重发一次之后，仍然得不到应答，等待2*500ms后再进行重传 如果仍然得不到应答，等待4*500ms进行重传，依次类推，以指数形式递增 累计到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接 连接管理机制在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接 重要的TCP状态： LISTEN：类似于手机开机，信号良好 ESTABLISHED：连接建立成功，可以进行通信了 CLOSE_WAIT：等待调用close函数，对端已经执行过close TIME_WAIT：保证最后一个ACK如果丢包，还有机会重传。即使客户端的进程已经退出，TIME_WAIT状态仍然可能会存在。如果此时最后一个ACK丢了，对端重传的FIN可以有机会去进行处理的TIME_WAIT会保持2MSL这样的时间 MSL表示网络中的两个节点之间，传输一个数据所经历的最大时间。CentOs7的MSL默认为60s 如果服务器端出现大量的CLOSE_WAIT状态是什么原因？ 代码中忘记调用close函数，代码中有bug 服务端状态转化 [CLOSED -&gt; LISTEN] 服务器端调用listen函数后进入LISTEN状态，等待客户端连接 [LISTEN -&gt; SYN_RCVD] 一旦监听到连接请求（SYN同步报文段），就将该连接放入内核等待队列中，并向客户端发送SYN确认报文段 [SYN_RCVD -&gt; ESTABLISHED] 服务器一旦受到客户端的确认报文，就进入ESTABLISHED状态，可以进行读写数据了 [ESTABLISHED -&gt; CLOSE_WAIT] 当客户端主动关闭连接（调用close），服务器会收到结束报文段，服务器返回确认报文段并进入CLOSE_WAIT; [CLOSE_WAIT -&gt; LAST_ACK] 进入CLOSE_WAIT后说明服务器准备关闭连接（需要处理完之前的数据）；当服务器真正调用close关闭连接时，会向客户端发送FIN，此时服务器进入LAST_ACK状态，等待最后一个ACK到来（这个ACK是客户端确认收到了FIN） [LAST_ACK -&gt; CLOSED] 服务器收到了对FIN的ACK，彻底关闭连接 客户端状态转化 [CLOSED -&gt; SYN_SENT] 客户端调用connect, 发送同步报文段 [SYN_SENT -&gt; ESTABLISHED] connect调用成功，则进入ESTABLISHED状态，开始读写数据 [ESTABLISHED -&gt; FIN_WAIT_1] 客户端主动调用close时，向服务器发送结束报文段，同时进入FIN_WAIT_1 [FIN_WAIT_1 -&gt; FIN_WAIT_2] 客户端收到服务器对结束报文段的确认，则进入FIN_WAIT_2，开始等待服务器的结束报文段 [FIN_WAIT_2 -&gt; TIME_WAIT]客户端收到服务器发来的结束报文段，进入TIME_WAIT，并发出LAST_ACK； [TIME_WAIT -&gt; CLOSED] 客户端要等待一个2MSL（Max Segment Life，报文最大生存时间）的时间，才会进入CLOSED状态。 理解TIME_WAIT状态 TCP协议规定，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态 我们使用Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口 MSL在RFC1122中规定为两分钟，但是各操作系统的实现不同，在Centos7上默认配置的值为60s 可以通过cat /proc/sys/net/ipv4/tcp_fin_timeout 查看msl的值 为什么TIME_WAIT的时间是2MSL？ MSL是TCP报文的最大生存时间，因此TIME_WAIT持续存在2MSL的话 就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的） 同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会再重发一个FIN，这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK）; 滑动窗口对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能较差，尤其是数据往返时间较长的时候 既然这样一发一收的方式性能较低。那么我们一次发送多条数据，就可以大大的提高性能（其实是将多个段的等待时间重叠在一起了） 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，上图的窗口大小就是4000个字节（四个段） 发送前四个段的时候，不需要等待任何ACK，直接发送； 收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据；依次类推； 操作系统内核为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有哪些数据没有应答；只有确认应答过的数据，才能从缓冲区删掉； 窗口越大，则网络的吞吐率就越高； 窗口也不能无限大 发送方如果发的太快，接收方可能处理不过来 发送方发送的数据先到达接收方的网卡，然后放到内核中的接收缓冲区中 接收方的用户代码从接收缓冲区中取数据(recv/read) 流量控制接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应 因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫做流量控制 接收端将自己可以接受的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK端通知发送端； 窗口大小字段越大，说明网络的吞吐量越高 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端 发送端接受到这个窗口之后，就会减慢自己的发送速度 如果接收端缓冲区满了，就会将窗口置为0；这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端 TCP协议报头中有一个窗口大小字段，这个字段是和接收缓冲区的空余空间大小相关联的 拥塞控制 根据丢包情况作为判定依据； 如果出现丢包，认为网络比较拥堵，如果没有丢包，认为网络比较畅通 TCP引入慢启动机制，先发少量的数据，开始的时候照一个比较小的窗口来发送数据 如果没有丢包，就按照指数形式提升窗口大小 如果窗口大小达到指定的阈值之后，变成线性增长 当窗口达到一定的大小之后，就会发生丢包，一旦丢包，认为网络拥堵，就把窗口大小一下就设回一个非常小的值，重复慢开始的过程 当TCP开始启动的时候，慢启动阈值等于窗口最大值 在每次超时重发的时候，慢启动阈值会变成原来的一半，同时拥塞窗口置回1 少量的丢包，我们仅仅是触发超时重传；大量的丢包，我们就认为网络拥塞 当TCP通信开始后，网络吞吐量会逐渐上升；随着网络发生拥堵，吞吐量就会立刻下降 拥塞控制，是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案 延迟应答 和滑动窗口密切相关，想办法在可靠性的前提下，尽量让窗口大（提高传输效率） 如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小 捎带应答 延迟应答的基础之上，引入的一个机制 TCP四次挥手有可能是三次，捎带应答在影响这件事情 面向字节流创建一个TCP的socket，同时会在内核中创建一个发送缓冲区和一个接收缓冲区 调用write时，数据会先写入发送缓冲区中 如果发送的字节数太长，会被拆分成多个TCP的数据包发出 如果发送的字节数太短，就会先在缓冲区里等待，等到缓冲区长度差不多了，或者其他合适的时机发送出去 接收数据的时候，数据也是从网卡驱动程序到达内核的接收缓冲区 然后应用程序可以调用read从接收缓冲区拿数据 另一方面，TCP的一个连接，既有发送缓冲区，也有接收缓冲区，那么对于这一个连接，既可以读数据，也可以写数据，这种叫做全双工 由于缓冲区的存在，TCP程序的读和写不需要一一匹配 粘包问题 面向字节流相关，应用程序如何能一次取出一个完整的应用层数据报 从应用层的角度来解决这个问题，只要能够确定数据报的数据报之间的边界就可以了 确定边界的方式有两个 分割符 指定长度 TCP VS UDP 如果需要可靠性（比如外网复杂的网络环境），优先考虑TCP 如果网络结构本身比较简单，可靠性比较高（机房内网），对传输效率要求更高，优先考虑UDP 如果你需要传输的数据包比较大，TCP（UDP的包有最大长度64k） 如果需要广播的话，只能用UDP，TCP不能广播]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>三次握手四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程信号]]></title>
    <url>%2F2019%2F06%2F08%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[进程信号信号概念 信号是进程之间事件异步通知的一种方式，属于软中断 使用kill -l命令可以查看系统定义的信号列表 每个信号都有一个编号和一个宏定义名称，这些宏定义可以在signal.h中找到，例如其中有定义#define SIGINT 2 编号34以上的是实时信号，我们暂时只关注编号34以下的实时信号。 我们用man [编号] signal的方式查看该信号在man手册中的具体说明 信号常见处理方式概览可选的处理动作有以下三种 忽略此信号 执行该信号的默认处理动作 提供一个信号处理函数，要求内核在处理该信号时切换到用户态执行这个处理函数，这种方式称为捕捉（Catch）一个信号 产生信号通过终端按键产生信号SIGINT的默认处理动作是终止进程，SIGQUIT的默认处理动作是终止进程并且Core Dump，我们可以用程序验证一下 调用系统函数向进程发信号 指定发送某种信号的kill命令可以有多种写法，上面的命令还可以写成kill -SIGSEGV 19745或kill -11 19745，11是信号SIGSEGV的编号。以往遇到的段错误都是由非法内存访问产生的，而这个程序本身没错，给它发送SIGSEGV也能产生段错误。 下面一段代码是我们常见的段错误产生 kill命令是调用kill函数实现的。kill函数可以给一个指定的进程发送指定的信号。false函数可以给当前进程发送指定的信号（自己给自己发送信号） 12345#include &lt;signal.h&gt;int kill(pid_t pid, int signo);int raise(int signo);//这两个函数都是成功返回0.错误返回-1 abort函数使当前进程接收到信号而异常终止 1234#include &lt;stdlib.h&gt;void abort(void);//就像exit函数一样,abort函数总是会成功的，所以没有返回值 由软件条件产生信号SIGPIPE是一种由软件条件产生的信号，我们可以用gdb调试该程序，看到这个信号 硬件异常产生信号硬件异常被硬件以某种方式被硬件检测到并通知内核，然后内核向当前进程发送适当的信号。例如当前进程执行了除以0的指令，CPU的运算单元会产生异常，内核将这个异常解释为SIGPIPE信号发送给进程。再比如当前进程访问了非法内存地址，MMU会产生异常，内核将这个异常解释为SIGSEGV信号发送给进程 信号捕捉代码如下 总结 所有信号的产生，由于OS是进程的管理者，最终都要由OS来进行执行 信号的处理是在合适的时候进行处理 信号的默认处理行为：大部分信号的默认行为，都是终止进程 信号处理函数是一个独立的执行流，和原来的用户代码之间没有相互调用关系 信号处理函数执行过程中，原有的执行流就在等待 signal替换了信号原有的处理方式（就会通过signal的返回值来返回） 阻塞信号信号其他相关常见概念 实际执行信号的处理动作成为信号递达(Delivery) 信号从产生到递达之间的状态，成为信号未决(Pending) 进程可以选择阻塞(Block)某个信号 被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作 注意，阻塞和忽略是不同的，只要信号被阻塞，就不会递达，而忽略是在递达之后可选的一种处理动作 task_struct 未决信号集：操作系统给进程发信号，本质上就是在未决信号集中写一个信号的信息（几号信号） 阻塞信号集：标识哪些信号不立刻处理，通过一些函数来操作阻塞信号集 信号处理函数集：函数指针数组 【重要】 同一时刻一个进程收到了大量的某个信号，极有可能只处理一次 每个信号都有两个标志位分别表示阻塞(block)和未决(pending)，还有一个函数指针表示处理动作，信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志。在上图的例子中，SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作 SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞 SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数sighandler。如果在进程解除对某信号的阻塞之前这种信号产生过多次，将如何处理？POSIX.1允许系统递送该信号一次或多次。Linux是这样实现的：常规信号在递达之前产生多次只记一次，而实时信号在递达之前产生多次可以依次放在一个队列里 捕捉信号内核如何实现信号的捕捉如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂。举例如下：用户程序注册了SIGQUIT信号的处理函数sighandler。当前正在执行main函数，这时发生中断或异常切换到内核态。在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用关系，是两个独立的控制流程。sighandler函数返回后自动执行特殊的系统调用sigreturn两次进入内核态，如果没有新的信号要递达，这次要返回用户态就是恢复main函数的下文继续执行 信号捕捉函数signal man 2 signal 可重入函数 一个函数如果在多个执行流中被调用，可能会出现问题 一个函数可重入，就意味着在多个执行流中调用是没问题的 一个函数如果不可重入，在多个执行流中调用就是有问题的 一个函数使用了全局变量，静态变量，不可重入 一个函数调用了malloc，不可重入 一个函数调用了不可重入函数，也是不可重入]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>信号捕捉</tag>
        <tag>可重入函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间的通信进程间通信介绍进程间通信目的 数据传输：一个进程需要将它的数据发送给另一个进程 资源共享：多个进程之间共享同样的资源 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程） 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进城的所有陷入和异常，并能够及时知道它的状态改变 进程间通信分类管道 匿名管道pipe 命名管道 System V IPC System V 消息队列 System V 共享内存 System V 信号量 POSIX IPC 消息队列 共享内存 信号量 互斥量 条件变量 读写锁 管道什么是管道 管道是Unix中最古老的进程间通信的形式 我们把从一个进程连接到另一个进程的一个数据流称为一个”管道“ 匿名管道123456#include &lt;unistd.h&gt;//功能：创建一个无名管道int pipe(int fd[2]);//参数//fd：文件描述符数组，其中fd[0]表示读端，fd[1]表示写端//返回值：成功返回0，失败返回错误代码 匿名管道代码 管道读写规则 当没有数据可读时 O_NONBLOCK disable：read调用阻塞，即进程暂停执行，一直等到有数据来到为止 O_NONBLOCK enable：read调用返回-1，errno值为EAGAIN 1- 当管道满的时候 O_NONBLOCK disable：write调用阻塞，直到有进程读走数据 O_NONBLOCK enable：调用返回-1，errno值为EAGAIN 如果所有管道写端对应的文件描述符被关闭，则read返回0 如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE,进而可能导致write进程退出 当要写入的数据量不大于PIPE_BUF时，Linux将保证写入的原子性 当要写入的数据量大于PIPE_BUF时，Linux将不在保证写入的原子性 管道的特点 只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信；通常，一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道 管道提供流式服务 一般而言，进程退出，管道释放，所以管道的生命周期随进程 一般而言，内核会对管道操作进行同步与互斥 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道 补充 管道中的数据一旦被读了之后，就相当于出队列了，假设有多个进程同时去尝试读，只有一个进程能读到数据，其他进程就读不到 管道内置了同步互斥机制，不会出现两个管道一人读一半数据的情况 多个进程同时去读写管道，数据不会发生错乱 如果管道为空尝试读，就会在read函数处阻塞 如果管道满了，尝试写，就会在write函数处阻塞 管道的大小（Centos7下）：64kb 两个没有亲缘关系的进程，无法共用一个管道，无法利用管道进行通信，所有引用该管道的进程都结束，管道才会释放 命名管道 管道应用的一个限制就是只能在具有共同祖先（具有亲缘关系）的进程间通信 如果我们想在不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它经常被称为命名管道 命名管道是一种特殊类型的文件 创建一个命名管道 命名管道可以从命令行上创建，命令行方法是使用下面这个命令 1$ mkfifo filename 命名管道也可以从程序里创建，相关函数有： 1int mkfifo(const char *filename, mode_t mode) 创建命名管道 12345int main()&#123; mkfifo("p2",0644); return 0;&#125; 匿名管道与命名管道的区别 匿名管道由pipe函数创建并打开 命名管道由mkfifo函数创建、打开用open FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在他们创建与打开的方式不同，一旦这些工作完成之后，它们具有相同的语义 命名管道的打开规则 如果当前打开操作是为读而打开FIFO时 O_NONBLOCK disable：阻塞直到有相应进程为写而打开该FIFO O_NONBLOCK enable：立刻返回成功 如果当前打开操作是为写而打开FIFO时 O_NONBLOCK disable：阻塞直到有相应进程为读而打开该FIFO O_NONBLOCK enable：立刻返回失败，错误码为ENXIO 运用命名管道实现读写操作 命名管道补充 对命名管道的操作和对文件的操作一模一样 read的返回值等于0：所有写端关闭，此时读端的read才返回0 命名管道的生命周期也是跟随进程，myfifo这个文件仅仅是一个入口，管道本体仍然是内核中的一块内存，生命周期其实是围绕着内核中的内存来讨论的 System V共享共享内存区是最快的IPC格式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据 共享内存函数 shmget函数 功能：用来创建共享内存 原型 ​ int shmget(key_t key, size_t size, int shmflg); 参数： ​ key：这个共享内存段名字 ​ size：共享内存大小 ​ shmflg：由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的 返回值：成功返回一个非负整数，即该共享内存段的标识码；失败返回-1 shmat函数 功能：将共享内存段连接到进程地址空间 原型： ​ void shmat(int shmid, const void shmaddr, int shmflg); 参数： ​ shmid：共享内存标识 ​ shmaddr：指定连续的地址 ​ shmflg：它的两个可能取值是SHM_RND和SHM_RDONLY 返回值：成功返回一个指针，指向共享内存第一个节；失败返回-1 创建共享内存完成读写 共享内存的使用方式 在内核中先创建出共享内存对象 多个进程附加到这个共享内存对象上 就可以直接读写这个共享内存了 在内核中可以同时包含很多共享内存对象，使用不同的key进行区分 共享内存补充 ipcs -m 查看系统中的共享内存 共享内存生命周期随内核，共享内存会一直存在到手动释放，或者系统重启]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>进程间</tag>
        <tag>匿名管道</tag>
        <tag>命名管道</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内联函数详解]]></title>
    <url>%2F2019%2F05%2F21%2FC-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[C++内联函数详解函数调用原理编译过程的最终产品是可执行程序–由一组机器语言指令组成。运行程序时，操作系统将这些指令载入计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环和分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销 内联函数内联函数提供了另一种选择，编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存 内联函数的使用在函数声明时加上关键字inline 在函数定义前加上关键字inline 示例如下： 123456789101112131415#include &lt;iostream&gt;inline double square(double x)&#123;return x*x;&#125;using namespace std;int main()&#123; double a,b; double c = 13.0; a = square(5.0); b = square(4.5 + 7.5); cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b = " &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "c squared = " &lt;&lt; square(c++) &lt;&lt; endl; cout &lt;&lt; "now c= " &lt;&lt; c &lt;&lt; endl; return 0;&#125; 程序输出结果如下：a = 25, b = 144 c = 13 c square = 169 now c = 14 内联函数与宏定义的区别C语言使用预处理器语句#define来提供宏。如下例所示： 123456789#define SQUARE(X) X*X//宏定义时通过文本替换开实现的--X是参数的符号标记a = square(5.0); //-&gt;5.0*5.0b = square(4.5 + 7.5); //-&gt;b = 4.5 + 7.5 * 4.5 + 7.5d = square(c++); //d = c++ * c++//可以看出，对于b，需要使用括号才能正常运算#define SQUARE(X) ((X)*(X))对于c,却仍递增了两次 因此，宏定义和内联函数存在本质的区别，转换的时候应考虑是否转换后功能是否正常 什么时候使用内联函数如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间 参考资料：《C++ Primer Plus》]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>内联函数</tag>
        <tag>宏定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector]]></title>
    <url>%2F2019%2F05%2F18%2Fvector%2F</url>
    <content type="text"><![CDATA[vectorvector介绍和使用vector的介绍 vector是表示可变大小数组的序列容器 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理 本质讲，vector使用动态分配数组来存储它的元素，当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小 vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长 与其它动态序列容器相比（deques,lists and forward_lists），vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好 vector的使用vector的定义 构造函数声明 接口说明 vector() 无参构造 vector(size_type n, const value_type&amp; val = value_type()) 构造并初始化n个val vector(const vector&amp; x); 拷贝构造 vector(InputIterator first,InputIterator last); 使用迭代器进行初始化构造 1234567891011121314151617181920212223//constructing vectors#include &lt;iostream&gt;#include &lt;vector&gt;int main()&#123; //constructors used in the same order as described above; std::vector&lt;int&gt; first; //empty vector of ints std::vector&lt;int&gt; second(4, 100); //four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end()); //iterating through second std::vector&lt;int&gt; fourth(third); //a copy of third int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints,myints + sizeof(myints)/sizeof(int)); std::cout &lt;&lt; "The contents of fifth are:"; //使用迭代器访问元素 for(std::vector&lt;int&gt;::iterator it = fifth.begin();it != fifth.end(); ++it) std::cout &lt;&lt; '' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; vector iterator 的使用 iterator的使用 接口说明 begin() 获取第一个数据位置的iterator end() 获取最后一个数据的下一个位置的iterator rbegin() 获取最后一个数据位置的reverse_iterator rend() 获取第一个数据前一个位置的reverse_iterator cbegin() 获取第一个数据位置的const_iterator cend() 获取最后一个数据的下一个位置的const_iterator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void PrintVector(const vector&lt;int&gt;&amp; v)&#123; //使用const迭代器进行遍历打印 vector&lt;int&gt;::const_iterator it = v.cbegin(); while(it != v.cend()) &#123; cout &lt;&lt; *it &lt;&lt; " "; ++it; &#125; cout &lt;&lt; endl;&#125;int main()&#123; //使用push_back插入4个数据 vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); //使用迭代器进行遍历打印 vector&lt;int&gt;::iterator it = v.begin(); while(it != v.end()) &#123; cout &lt;&lt; *it &lt;&lt; " "; ++it; &#125; cout &lt;&lt; endl; //使用迭代器进行修改 it = v.begin(); while(it != v.end()) &#123; *it *= 2; ++it; &#125; //使用反向迭代器进行遍历再打印 vector&lt;int&gt;::reverse_iterator rit = v.rbegin(); while(rit != v.rend()) &#123; cout &lt;&lt; *rit &lt;&lt; " "; ++rit; &#125; cout &lt;&lt; endl; PrintVector(v); return 0;&#125; vector空间增长问题 容量空间 接口说明 size() 获取数据个数 capacity() 获取容量大小 empty() 判断是否为空 void resize(size_tyoe n, value_type val = value_type()); 改变vector的size void reserve(size_type n); 改变vector放入capacity capacity的代码在vs和g++下分别运行会发现，vs下capacity是按1.5倍增长的，g++是按2倍增长的，具体增长多少是根据具体的需求定义的。vs是PJ版本STL,g++是SGI版本的STL reserve只负责开辟空间，如果确定知道需要用多少空间，reserve可以理解vector增容的代价缺陷问题 resize在开空间的同时还会进行初始化，影响size vector增删查改 vetcor增删查改 接口说明 void push_back(const value_type&amp; val); 尾插 void pop_back(); 尾删 InputIterator find(InputIterator first,InputIterator last,const T&amp; val); 查找。（这个是算法模块实现，不是vector的成员接口） iterator insert(iterator position,const value_type&amp; val); 在position之前插入val iterator erase(iterator position); 删除position位置的数据 void swap(vector&amp; x); 交换两个vector的数据空间 reference operator[] (size_type n); 像数组一样用[]访问 vector迭代器失效问题123456789101112131415161718192021222324252627//insert/erase导致的迭代器失效#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a[] = &#123;1,2,3,4&#125;; vector&lt;int&gt; v(a,a + sizeof(a)/sizeof(int)); //使用find查找3所在位置的iterator vector&lt;int&gt;::iterator pos = find(v.begin(),v.end(),3); //删除pos位置的数据，导致pos迭代器失效 v.erase(pos); cout &lt;&lt; *pos &lt;&lt; endl;//此处会导致非法访问 //在pos位置插入数据，导致pos迭代器失效 //insert会导致迭代器失效，是因为insert可能会导致增容 //增容后pos还指向原来的空间，而原来的空间已经释放了 pos = find(v.begin(), v.end(), 3); v.insert(pos, 30); cout &lt;&lt; *pos &lt;&lt; endl;//此处会导致非法访问 return 0;&#125;]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各类排序算法总结]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[各类排序算法总结排序的概念排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作 稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j],且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的，否则称为不稳定的。 内部排序：数据元素全部放在内存中的排序 外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序 常见的排序算法 常见排序算法的实现插入排序基本思想： 直接插入排序（Straight Insertion Sort）的基本思想是：把n个待排序的元素看称为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1此可完成排序过程。 直接插入排序当插入第i(i&gt;=1)个元素时，前面的array[0],……,array[i-1]已经排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移 插入排序的代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void InsertSort(int array[], int size)&#123; int i; for(i = 1;i &lt; size; i++) &#123; int j; int k = array[i]; //为array[i]在前面的有序区间中找一个合适的位置 for(i = i - 1; j &gt;= 0; j--) &#123; if(array[j] &lt; k) &#123; break; &#125; else//找到该位置 将比它大的数据向后移动 &#123; array[j + 1] = array[j]; &#125; &#125; //将array[i]放到正确的位置上 array[j + 1] = k; &#125;&#125; 直接插入排序的特性总结： 元素集合越接近有序，直接插入排序算法的时间效率越高 时间复杂度：O(N^2) 空间复杂度：O(1),它是一种稳定的排序算法 稳定性：稳定 希尔排序（缩小增量排序）希尔排序法又称为缩小增量法（Diminshing Increment Sort），是直接插入排序算法的一种更高效的改进版本，希尔排序是非不稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所有记录放在同一组中进行直接插入排序为止。 该方法实质上是一种分组插入方法 比较相隔较远距离（称为增量）的数，使得移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序，当增量减到1时，整个要排序的数组被分成一组，排序完成。 希尔排序的代码如下: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;void ShellSort(int array[], int size)&#123; int gap = size; while(1) &#123; gap = gap / 3 + 1; InsertSortWithGap(array, size, gap); if(gap == 1) &#123; break; &#125; &#125;&#125;void InsertSortWithGap(int array[], int size, int gap)&#123; int i; for(i = gap; i &lt; size; i++) &#123; int k = array[i]; int j; for(j = i - gap; j &gt;= 0; j -= gap) &#123; if(array[j] &lt; k) &#123; break; &#125; else &#123; array[j + gap] = array[j]; &#125; &#125; array[j + gap] = k; &#125;&#125; 希尔排序特性总结; 希尔排序是对直接插入排序的优化 当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试对比 希尔排序的时间复杂度不好计算，需要进行推导，推导出来平均时间复杂度: O(N^1.3 - N^2) 稳定性：不稳定 选择排序基本思想： 每一次从待排序的数据元素中选出最小或（最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 直接选择排序 在元素集合 array[i] — array[n - 1]中选择关键码最大（小）的数据元素 若它不是这组元素中的最后一个（第一个元素），则将它与这组元素中的最后一个（第一个）元素交换 在剩余的 array[i] — array[n - 2] (array[i + 1] — array[n - 1])集合中，重复上述步骤，直到集合剩余1个元素 算法分析 直接选择排序效率不是很好，实际中很少使用 时间复杂度：O(N^2) 空间复杂度：O(1) 稳定性：不稳定 选择排序代码如下123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void SelectSort(int array[], int size)&#123; int i, min, j; for(i = 0; i &lt; size - 1; i++) &#123; min = i; for(j = i + 1; j &lt; size; j++) &#123; if(array[j] &lt; array[min]) &#123; min = j; &#125; &#125; if(array[i] &gt; array[min]) &#123; int tmp = array[min]; array[min] = array[i]; array[i] = tmp; &#125; &#125;&#125; 堆排序堆排序(HeapSort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。 堆排序算法分析 堆排序使用堆来选数，效率就高了很多 时间复杂度：O(N*logN) 空间复杂度：O(1) 稳定性：不稳定 堆排序基本思想：将待排序序列构造成一个大堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n - 1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 堆排序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#pragma once#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;assert.h&gt;typedef struct Heap&#123; int array[100]; int size;&#125;Heap;//初始化void HeapInit(Heap* heap, int array[], int size)&#123; memcpy(heap-&gt;array, array, size * sizeof(int)); heap-&gt;size = size; CreateHeap(heap-&gt;array, heap-&gt;size);&#125;//插入void HeapPush(Heap* heap, int value)&#123; heap-&gt;array[heap-&gt;size] = value; heap-&gt;size++; AdjustUp(heap-&gt;array,heap-&gt;size,heap-&gt;size-1);&#125;//删除//1.只能删除堆顶元素，其它位置没有意义//2.最尾元素覆盖堆顶元素void HeapPop(Heap* heap)&#123; heap-&gt;array[0] = heap-&gt;array[heap-&gt;size-1]; AdjustDown(heap-&gt;array,heap-&gt;size - 1); heap-&gt;size--;&#125;//返回堆顶元素（最值）int HeapTop(Heap* heap)&#123; return heap-&gt;array[0];&#125;//打印元素void PrintArray(int array[], int size)&#123; for(int i = 0; i &lt; size; i++) &#123; printf("%d\t",array[i]); &#125; printf("\n");&#125;//向上调整//child:要向上调整的节点的下标//终止条件://1.比不过parent//2.已经是最顶了void AdjustUp(int array[], int size, int child)&#123; while(1) &#123; if(child == 0) &#123; return; &#125; int parent = (child - 1) / 2; if(array[parent] &lt;= array[child]) &#123; return; &#125; int t = array[parent]; array[parent] = array[child]; array[child] = t; child = parent; &#125;&#125;//向下调整void AdjustDown(int array[], int size, int root)&#123; while(1) &#123; assert(array != NULL); if(root &gt;= size || root &lt; 0) &#123; return; &#125; //判断root是否为叶子结点 int left = 2*root + 1; if(left &gt;= size)//是叶子节点 &#123; return; &#125; int right = 2 * root + 2; int min = left; //找到最小的一个 if(right &lt; size &amp;&amp; array[right] &lt; array[left]) &#123; min = right; &#125; if(array[root] &lt;= array[min]) &#123; return; &#125; int t = array[root]; array[root] = array[min]; array[min] = t; root = min; &#125;&#125;//建堆void CreateHeap(int array[], int size)&#123; for(int i = (size - 2) / 2; i &gt;= 0; i--) &#123; AdjustDown(array, size, i); &#125;&#125;//堆排序void HeapSort(int array[], int size)&#123; CreateHeap(array, size); for(int i = 0; i &lt; size - 1; i++) &#123; int t = array[i]; array[i] = array[size - 1 - i]; array[size - 1 - i] = t; AdjustDown(array,size - 1 - i, 0); &#125;&#125; 交换排序基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。 冒泡排序 冒泡排序代码 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void BubbleSort(int array[], int size)&#123; int i; for(i = 0; i &lt; size - 1; i++) &#123; int j; for(j = size - 1; j &gt; i; j--) &#123; if(array[j] &lt; array[j - 1]) &#123; int tmp = array[j]; array[j] = array[j - 1]; array[j - 1] = array[j]; &#125; &#125; &#125;&#125; 冒泡排序算法分析 冒泡排序是一种非常容易理解的排序 时间复杂度：O(N^2) 空间复杂度：O(1) 稳定性：稳定 快速排序快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素排列在相应位置上为止 将区间按照基准值划分为左右两半部分的常见方式有： hoare版本 挖坑法 前后指针版本]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程状态及控制]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程状态和控制所有多道程序操作系统，从Windows这种单用户系统到IBM z/OS这种支持成千上万用户的主机系统都是围绕进程这一概念创建的。因此，操作系统须满足的多数需求都设计进程： 操作系统与普通计算机软件的作用相同，即它是由处理器执行的一段程序或一组程序 操作系统必须交替执行多个进程，在合理的响应时间范围内使处理器的利用率最大 操作系统必须按照特定的策略（如某些函数或应用程序具有较高的优先级）给进程分配资源，同时避免死锁 操作系统须为有助于构建应用的进程间通信和用户进程创建提供支持 什么是进程背景先介绍一下计算机相关概念 计算机平台由一组硬件资源组成，如处理器、内存、I/O模块、定时器和磁盘驱动器等 计算机程序是为执行某些任务而开发的。典型情况下，它们接受外来的输入，做一些处理后，输出结果 直接根据给定的硬件平台写应用程序的效率底下，主要原因如下： 针对相同的平台可以开发出很多应用程序，所以开发出这些应用程序访问计算机资源的通用例程很有意义 处理器本身只能对多道程序设计提供有限的支持，需要用软件去管理处理器和被多个程序共享的其他资源 若多个程序在同一时间都是活跃的，则需要保护每个程序的数据、I/O使用和不被其它程序占用的资源 开发操作系统是为了给应用程序提供方便、安全和一致的接口。操作系统是计算机硬件和应用程序之间的一层软件，它为应用程序和工具提供支持 操作系统可想象为资源的统一抽象表示，它可被应用程序请求和访问。资源包括内存、网络接口和文件系统等。操作系统为应用程序创建这些资源的抽象表示后，就须管理它们的使用，例如操作系统既可允许资源共享，也可允许资源保护 有了应用程序、系统软件和资源的概念，就可讨论操作系统有序管理应用程序的执行的方式，进而达到如下目标： 资源对多个应用程序是可用的 物理处理器在多个应用程序间切换，以保证所有程序都在执行中 处理器和I/O设备能得到充分利用 所有现代操作系统采用的方法都依赖于一个模型，在该模型中，应用程序的执行对应于存在的一个或多个进程 进程和进程控制块进程的定义 一个正在执行的程序 一个正在计算机上执行的实例 能分配给处理器并由处理器执行的实体 由一组执行的指令、一个当前状态和一组相关的系统资源表征的活动单元 也可把进程视为由一组元素组成的实体，进程的两个基本元素是程序代码（program code，可能被执行相同程序的其他进程共享）和与代码相关联的数据集（set of data）。假设处理器开始执行这个程序代码，并且我们把这个执行实体称为进程。进程执行的任意时刻，都可由如下元素来表征： 标识符：与进程相关的唯一标识符，用来区分其他进程 状态：若进程正在执行，则进程处于运行态 优先级：相对于其他进程的优先顺序 程序计数器：程序中即将执行的下一条指令的地址 内存指针：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针 上下文数据：进程执行时处理器的寄存器中的数据 I/O状态信息：包括显式 I/O 请求、分配给进程的I/O设备（如磁盘驱动器）和被进程使用的文件列表等。 记账信息：包括处理器时间总和、使用的时钟数总和、时间限制、记账号等 上述列表信息存放在一个称为进程控制块（process control block）的数据结构中，控制块由操作系统创建和管理。比较有意义的一点是，进程控制块包含了充分的信息，因此可以中断一个进程的执行，并在后来恢复进程的执行，就好像进程未被中断过那样。进程控制块是操作系统为支持多进程并提供多重处理技术的关键工具。进程中断时，操作系统会把程序计数器和处理器寄存器（上下文数据）保存到进程控制块中的相应位置，进程状态相应地改为其他值，如阻塞态或就绪态（后面将讲述）。现代操作系统可以随意将其它进程置为运行态，并把它的程序计数器和进程上下文数据加载到处理器寄存器中，进而执行这一进程 因此，我们可以说进程由程序代码和相关数据及进程控制块组成。单处理器计算机在任何时刻最多都只能执行一个进程，而正在运行的进程的状态为运行态 通过系统调用获取进程提示符 进程id（PID） 父进程（PPID） 12345678910#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; printf("pid:%d\n",getpid());//获取当前进程的PID printf("ppid:%d\n",getppid());//获取当前进程的父进程的PID return 0;&#125; 进程状态操作系统会为待执行程序创建进程或任务。处理器以某种顺序执行指令序列中的指令，这种顺序由程序计数器寄存器中不断变化的值给出，因为程序计数器可能会指向不同进程的不同代码部分，程序的执行则涉及其内部的一系列指令。 列出为进程执行的指令序列，可描述单个进程的行为，这样的序列称为进程轨迹（trace）。给出各个进程轨迹的交替方式，就可描述处理器的行为。 通过观察可知，在任何时刻，一个进程要么正在执行，要么未执行，因此进程可以处于以下两种状态之一：运行态或未运行态。操作系统创建一个新进程时，它将该进程以未运行态加入系统，操作系统知道这个进程的存在，并正在等待执行机会。时而不时的，当前正在运行的进程会被中断，此时操作系统的分派器部分将选择一个新进程运行，前一个进程从运行态转换为未运行态，后一个进程则转换为运行态。 一个进程可以有几个状态（在Linux内赫里，进程有时候也叫做任务）。下面的状态kernel源代码里定义： R运行状态（running）：并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里 S睡眠状态（sleeping）：意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（inerruptible sleep）） D磁盘休眠状态（stopped）：可以通过发送SIGSTOP信号给进程来停止（T）进程。这个被暂停的进程可以通过发送SIGCONT信号让进程继续运行 X死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态 使用ps aux / ps axj命令来查看进程状态 Z（zombie）-僵尸进程 僵尸状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程没有读取到子进程退出返回代码时就会产生僵死（尸）进程 僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码 所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态 僵尸进程代码实现 我们运行该段程序，然后发现该进程的运行结果如下： 然后查看子进程状态如下： 僵尸进程危害 进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），可父进程如果一直不读取，那么子进程就一直处于Z状态 维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，Z状态一直不退出，PCB一直都要维护 那一个父进程创建了很多子进程，就是不回收，就会造成内存资源的浪费，因为数据结构对象本身就要占用内存。 会造成内存泄漏 僵尸进程的处理直接kill僵尸进程是不行的，可以直接kill僵尸进程的父进程 更加科学的处理：进程等待 为什么kill掉父进程僵尸进程就没了？ 当kill掉父进程之后，子进程就成了孤儿进程，孤儿进程会被1号进程收养，从而释放资源 孤儿进程 父进程先退出，子进程就称之为“孤儿进程” 孤儿进程被1号init进程领养，当然由init进程回收 孤儿进程代码： 运行可执行程序，得到如下结果： 由结果可见该进程被1号进程领养，我们再来看看该进程的状态 进程的创建和终止无论使用哪种进程行为模型，进程的生存期都围绕着进程的创建和终止。 进程的创建将一个新进程添加到正被管理的进程集时，操作系统需要建立用于管理该进程的数据结构，并在内存中给它分配地址空间，这些行为构成了一个新进程的创建过程。 触发进程创建的事件通常有4个，在批处理环境中，响应作业提交时会创建进程：在交互环境中，当新用户试图登陆时会创建进程，不论哪种情况，操作系统都负责新进程的创建工作。操作系统也可能会代表应用程序创建进程。例如，如果用户请求打印一个文件，则操作系统可以创建一个管理打印的进程，进而使请求进程可以继续执行，与完成打印任务的时间无关。 事件 说明 新的批处理作业 磁带或磁盘中的批处理作业控制流通常会提供给操作系统，当操作系统准备接受新工作时，将读取下一个作业控制命令 交互登陆 终端用户登录到系统 为提供服务而由操作系统创建 操作系统可以创建一个进程，代表用户程序执行一个功能，使用户无须等待（如控制打印的进程） 由现有进程派生 基于模块化的考虑或开发并行性，用户程序可以指示创建多个进程 传统上，操作系统会以对用户或应用程序透明的方式来创建所有进程，这在许多现代操作系统中仍很常见。但是，允许一个进程引发另一个进程的创建很有用。例如，一个应用程序进程可以产生另一个进程，以接收应用程序产生的数据，并将数据组织成适合于后续分析的格式。新程序与应用程序并行运行，并在得到新数据时激活。这种方案对构造应用程序非常有用，例如，服务器进程（如打印服务器、文件服务器）可以为它处理的每个请求产生一个新进程。当操作系统为另一个进程的显示请求创建一个进程时，这个动作就称为进程派生。 当一个进程派生另一个进程时，前一个称为父进程（parent process），被派生的进程称为子进程（child process）。典型情况下，相关进程需要相互之间的通信和合作。对程序员来说，合作是一项非常困难的任务。 fork函数在Linux中fork函数是非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程 fork的运行规则以父进程为模板，创建子进程 会把父进程的PCB拷贝一份，稍加修改，成为子进程的PCB 会把父进程的虚拟地址空间拷贝一份，作为子进程的地址空间 写时拷贝 = &gt; 父子进程共用一份代码，各自有一份数据 由于大部分的内存空间可能被拷贝，创建进程开销仍然比较高（和线程相比） 在有些场景下，线程的创建也会被认为开销比较高（和协程相比） fork()返回值会在父子进程中分别返回 父进程中返回子进程的PID 子进程中返回0 失败返回-1（原因：1）内存不够 2）进程太多） 在fork()后面继续往下执行 父子进程执行顺序没有先后关系，全靠调度器来实现 进程终止进程退出场景 代码运行完毕，结果正确 代码运行完毕，结果不正确 代码没执行完，异常终止 进程常见退出方法正常终止（可以通过echo $? 查看进程退出码）$?这是bash中的一个特殊变量，表示上个命令对应的进程的退出码 从main函数返回，返回值叫做进程的退出码，通过这个退出码表示运行结果是否正确（也能刷新缓冲区） 退出码为0，表示结果正确 退出码非0表示结果不正确 调用exit函数（库函数调用）exit本质上也是调用_exit exit关闭流并刷新缓冲区 exit还多调用了结束函数 调用_exit函数（系统调用）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么在调试的时候需要在编译选项中加上-g选项]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%9C%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E4%B8%AD%E5%8A%A0%E4%B8%8A-g%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[为什么在调试的时候需要在编译选项中加上 -g 选项默认编译生成的可执行文件是无法使用gdb来进行跟踪或调试的，因为可执行程序中没有可供gdb调试使用的特殊信息，为了将必要的调试信息整合到可执行文件中，我们便需要用到-g选项，这样生成的可执行程序，倘若出现问题，便可以使用gdb找出问题具体出现的位置，便于问题的解决 方法如下 “-g” 标志是对程序进行调试性编译时常用的选项。我们需要给每一个需要调试的源文件都加上这个选项。它将使用特殊版本的C语言标准库完成编译和链接操作，给库函数加上程序调试方面的支持。编译器会把这些标志自动传给链接器。 加上-g 选项以后，gcc在编译是会做出一下额外的操作 创建符号表，符号表包含了程序中使用的变量名称的列表 关闭所有的优化机制，以便程序执行过程中严格按照原来的C代码进行]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的编译器有哪些]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[常用的编译器MSVCWindows平台上最常用的编译器，在C++编译器圣战中的胜利者，一个常被人诟病的是对标准的支持不够新不够快（最近逐步加快）。随着微软发布基于Clang/C2，这条路以后若能成功，MSVC与Clang/C2并行，甚至逐步退出舞台，都是有可能的事情 Clanglicence极度友好，代码质量非常棒，采用的IR为LLVM IR非常优秀，各大公司逐步发力在Clang上，包括不限于微软，IBM,Nvidia GPU等支持，目前在赶超GCC的道路上一路激情地狂奔，前途一片光明。但是Clang依赖于的LLVM，目前性能无法与GCC相提并论，在Benchmark性能测试上几乎没有胜利的项目，优化的道路上任重道远，同时一些开源软件没有办法编译过去，主要是缺乏对GCC一些Builtin函数、自身带的汇编器不争气导致。 GCC/G++跨体系结构很多，很多开源软件默认编译器都是GCC/G++,这一点上Clang比不上 并且开源，Linux/Unix平台上的首选，而且支持N中硬件平台，如果想进行跨平台编译的话，这是一个不错的选择。编译效率和编译后的代码效率都不错 ICC没有自己专门的前端（传说中的外包），而且是针对Intel体系结构上专门优化 IBM XL C++在IBM上特定硬件与平台上表现非常牛逼，Benchmark性能测试非常优秀，其最初的设计思想就是为了性能，其最高优化级别可以达到O5，带来的缺点则是在编译时间上往往过长。而另外一个常被人诟病的是对C++标准的支持、开源软件的支持、错误信息的提示上都不够友好，然而从13.2开始，随着IBM采用Clang融合方案，目前这几项都得到有效改良，然而融合的道路也必定是漫长的。 VisualC++Windows平台上最流行的编译器，和VS集成的和很好，编译效率和编译后的代码效率都不错 VS系列微软的Visual Studio，目前最全面的功能强大的主流IDE环境]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体 以及内存对齐相关问题]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%BB%93%E6%9E%84%E4%BD%93-%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[结构体 及其内存对齐相关问题结构体结构体的声明1234struct tag&#123; number-list;&#125;variable-list; 例如描述一个学生 1234567struct stu&#123; char name[20]; //名字 int age; //年龄 char sex[5]; //性别 char id[20]; //学号&#125;;//分号不能没有 特殊的声明：在声明结构体的时候，可以不完全的声明 比如： 123456789101112131415//匿名结构体类型struct&#123; int a; char b; float c;&#125;x;struct&#123; int a; char b; float c;&#125;a[20],*p; 警告：编译器会把上面的两个声明当成完全不同的两个类型。所以是非法的 结构体的自引用1234567891011struct Node&#123; int data; struct Node* next;&#125;;typedef struct Node&#123; int data; struct Node* next;&#125;Node; 结构体变量的定义和初始化有了结构体类型，则如下定义变量 1234567891011121314151617181920212223242526struct Point&#123; int x; int y;&#125;p1; //声明类型的同时定义变量p1;struct point p2; //定义结构体变量p2//初始化：定义变量的同时赋初值struct Point p3 = &#123;x,y&#125;;struct Stu //类型声明&#123; char name[15]; //名字 int age; //年龄&#125;;struct Stu s = &#123;"zhangsan",20&#125;;//初始化struct Stu&#123; int data; struct Point p; struct Node* next;&#125;n1 = &#123;10,&#123;4,5&#125;,NULL&#125;; //结构体嵌套初始化struct Node n2 = &#123;20,&#123;5,6&#125;,NULL&#125;; 结构体只能整体初始化，不能被整体赋值 结构体内存对齐为什么要有结构体内存对齐?平台原因不是所有的硬件都能随意的访问任意地址处的任意数据，有的CPU只能从内存上地址为4的倍数的地址处读取数据，而为了可以读取结构体数据，结构体的起始位置的地址理所应当的为4的倍数，而在结构体内部维护内存对齐是为了迎合硬件的这一特性 性能原因因为为了CPU能够快速访问，提高访问效率，变量的起始地址应该具有这些特性，这就是所谓的”对齐”。例如在32位平台上，CPU一个只可以读取出4字节的内容，且只可以在4的整数倍位置进行访问，而当结构体中存放一个int类型变量时，结构体的起始位置一定是4的倍数，此时若在结构体内部不维护内存对齐，则取出一个整型的4字节，若该int变量的偏移量为3，则就需要先读取偏移量为0向后的4个字节，将最后一个字节中属于int成员变量的数据保存下来，再读取偏移量为4向后的4字节，将前这4字节中属于int成员变量的前3字节的数据再次保存，之后将这两段数据进行拼接，才能得到完整的int成员变量 结构体内存对齐规则 第一个成员在与结构体变量偏移量为0的地址处 当程序要存储一个结构体时，会在内存上的某一个地址处开始存储这个结构体，这时不论这个结构体的第一个成员是什么，都要从该地址的0偏移量处开始存储 其他成员变量要对齐到某个数字（对齐数）的整数倍的偏移量的地址处。对齐数 = 编译器的默认的对齐数与该成员大小的较小值 对齐数 = 编译器默认对齐数 &lt; 成员大小 ? 编译器默认对齐数 : 成员大小。 这里使用例子来帮助理解: ​ 假如第一个成员使用了1个字节的内存，这时按照道理应该就从偏移量为1的地方开始存放第一个成员（假设第二个成员大小为4），但是编译器并不是这样的，编译器先计算出对于第二个成员变量的对齐数（vs默认对齐数为8，Linux默认对齐数为4）为4，检测到偏移量为1，但1并不是4的整数倍，那么就要继续向后找，直到找到偏移量为4，偏移量为4恰好是4的整数倍，那么就可以从偏移量为4的位置开始存储第二个成员变量了。 ​ 这时紧接着又要存放第三个成员变量（假设第三个成员变量的大小为1），这时候编译器先要计算出属于第三个成员变量的默认对齐数为1，接下来编译器就来看看下一个位置的偏移量符不符合要求，下一个位置的偏移量为9，9是1的整数倍，所以第三个成员变量就从偏移量为9的位置开始存放了 Linux默认偏移量为4 vs默认对齐数是8 结构体的总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍 当编译器将结构体的成员数据都存储完成之后，接下来就会计算出这些成员变量中的最大对齐数（在本例中为4），得知最大的对齐数为4，编译器就会查看当前结构体的总大小，发现当前结构体的总大小为9，9并不是4的整数倍，那么编译器就继续占用空间，占到12时就会停止，因为12是4的整数倍 如果结构体内部嵌套了别的结构体，嵌套结构体的对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的所有成员的对齐数）的整数倍 也就是说，当一个结构体内嵌套了另外一个结构体时，被嵌套的结构体成员变量存放完成时要计算最大对齐数只需要从自己的成员变量对齐数中选出最大的即可，但是外部的结构体成员变量存放完成之后计算最大结构体时，要从自己的成员变量的对齐数和嵌套的结构提的成员变量的对齐数中挑选出一个最大的对齐数。 编译器存储一个结构体的过程当一个结构体要存储在内存中时，编译器会做如下的事情： 首先一个结构体要存储到内存中时，编译器首先会分配一个地址，作为该结构体的起始位置 编译器先拿到结构体的第一个成员变量，直接从相对起始位置0偏移量的位置开始存放第一个成员变量 第N（N = 1，2，3，…）成员变量存放完成之后，编译器又拿到第N + 1成员变量，此时编译器就要计算第N + 1个成员变量的大小（用来计算该成员变量的对齐数），使用该成员变量的大小与编译器的默认对齐数比较，较小的即就是该成员变量的对齐数，拿到对齐数之后，检测当前的偏移量是否为对齐数的整数倍。 如果是，编译器从当前偏移量位置开始存放第N + 1个成员变量 如果不是，编译器向后偏移（占用空间），直到偏移量为该成员变量对齐数的整数倍之后，开始从当前偏移量位置存放第N + 1个成员变量 当所有的结构体成员存放完成之后，编译器会回想出成员变量中最大的对齐数，之后检测当前结构体大小是否为最大对齐数的整数倍。 如果是，则结构体存放全部完成 如果不是，编译器继续向后偏移（占用空间），直到当前结构体大小为最大对齐数的整数倍，则结构体存放全部完成 查看结构体中变量相对起始位置的偏移量123456#include &lt;stddef.h&gt;size_t offsetof(type,member);//源码#define offsetof(s, m)(size_t)&amp;(((s*)0)-&gt;m) 参数 type：结构体类型 member：结构体的成员 返回值 结构体成员相对与结构体起始位置的偏移量 改变结构体的默认对齐数1#pragma pack(N) 使用N来改变编译器的默认对齐数为N 1#pragma pack() 恢复编译器的默认对齐数 位段位段不跨平台 位段与结构体的区别 位段的成员必须是int,usigned int,signed int 位段的成员名之后必须要有一个冒号和一个数字 位段的例子1234567struct A&#123; int a:2;//a成员只需要2个比特位 int b:4;//b成员只需要4个比特位 int c:8;//c成员只需要8个比特位 int d:20;//d成员需要20个比特位&#125;; 位段存放成员的方式不同的编译器存放位段的方式是不同的，所以位段是不跨平台的。但主要有以下两种方式，这里使用一个简单的位段来描述这个问题 1234567struct A&#123; int a:2; int b:8; int c:10; int d:30;&#125;; 编译器先开辟一个（int）4字节用来存放位段，位段的第一个成员使用2个比特位，则编译器将开辟好的字节的前两个比特位分配给第一个成员，此时还是=剩下30个比特位，第二个成员需要8个比特位，则编译器又分配了8个比特位给第二个成员，此时还剩下22个比特位，第三个成员需要10个比特位，则编译器又分配10个比特位给第三个成员，此时开辟好的空间只剩下12个比特位，但此时第四个成员需要30个比特位，在此时不同的编译器就会有不同的处理方式: 一种编译器会直接浪费掉剩下的12个字节，为第四个成员重新开辟一个(int)4字节的内存来存放 零一种编译器会将第四个成员变量的前12个字节存进剩下的空间中，为剩余的成员重新开辟内存存放 位段存在的问题 不可移植性，位段在不同的系统中会出现不同的结果 int位段被当作有符号数还是无符号数是不可预计的 位段中最大位的数目是不确定的 位段中的成员在内存中从左向右分配，还是从右向左分配是没有经过定义的 联合体（共用体）联合体也是一种特殊的自定义类型，这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块内存空间 联合体的内存分配规则 联合体分配的大小位成员变量中最大的成员大小 联合体的总大小必须是联合体成员中最大对齐数的整数倍 联合体的特性判断机器的大小端存储]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态多态的概念多态的概念: 通俗来说,就是多种形态，具体点就是完成某个行为，当不同的对象去完成时会产生不同的状态 多态的定义及实现多态定义的构成条件多态是在不同继承关系的类对象，去调用同一函数，产生了不同行为，比如Student继承了Person。Person对象买票全价，Student对象买票半价。 那么在继承重要构成多态还有两个条件: 调用函数的对象必须是指针或者引用 被调用的函数必须是虚函数，且完成了虚函数的重写 什么是虚函数虚函数: 就是在类的成员函数前面加virtual关键字 12345678class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票,全价" &lt;&lt;endl; &#125;&#125;; 什么是虚函数的重写虚函数的重写：派生类中有一个跟基类的完全相同的虚函数，我们就称子类的虚函数重写了基类的虚函数，完全相同是指: 函数名、参数、返回值都相同，另外虚函数的重写也叫作虚函数的覆盖。 12345678910111213141516171819202122232425262728293031class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票，全价" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票,半价" &lt;&lt; endl; &#125;&#125;void Func(Person&amp; p)&#123; p.BuyTicket();&#125;int main()&#123; Person ps; Student st; Func(ps); Func(st); return 0;&#125; 虚函数重写的例外：协变虚函数重写有一个例外：重写的虚函数的返回值可以不同，但是必须分别是基类指针和派生类指针或者基类引用和派生类引用。 1234567891011121314151617181920class A&#123;&#125;;class B : public A&#123;&#125;;class Person&#123;public: virtual A* f() &#123; return new A; &#125;&#125;;class Student : public Person&#123;public: virtual B* f() &#123; return new B; &#125;&#125;; 不规范的重写行为在派生类中重写的成员函数可以不加virtual关键字，也是构成重写的，因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性，我们只是重写了它。但是这是非常不规范的。 12345678910111213141516class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票 全价" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: void BuyTicket() &#123; cout &lt;&lt; "买票 半价" &lt;&lt; endl; &#125;&#125;; 析构函数的重写问题基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里它们的函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor,这也说明的基类的析构函数最好写成虚函数 12345678910111213141516171819202122232425262728class Person&#123;public: virtual ~Person() &#123; cout &lt;&lt; "~Person()" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: virtual ~Student() &#123; cout &lt;&lt; "~Student()" &lt;&lt; endl; &#125;&#125;;//只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成多态，才能保证p1和p2指向的对象正确的调用析构函数int main()&#123; Person* p1 = new Person; Person* p2 = new Student; delete p1; delete p2; return 0;&#125; 接口继承和实现继承普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现，虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口，所以如果不实现多态，不要把函数定义为虚函数。 重载、覆盖（重写）、隐藏（重定义）的对比 重载：两个函数在同一作用域,函数名相同、参数不同 重写(覆盖): 两个函数分别在基类和派生类的作用域，函数名/参数/返回值都必须相同(协变例外)，两个函数必须是虚函数 重定义(隐藏)：两个函数分别在基类和派生类的作用域，函数名相同，两个基类和派生类的同名函数不构成重写就是重定义 抽象类在虚函数的后面写上 = 0, 则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫做接口类），抽象类不能实例化对象。派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Car&#123;public: virtual void Drive() = 0;&#125;;class Benz : public Car&#123;public: virtual void Drive() &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125;&#125;;class BMW : public Car&#123;public: virtual void Drive() &#123; cout &lt;&lt; "BMW-操控" &lt;&lt; endl; &#125;&#125;;void Test()&#123; Car* pBenz = new Benz; pBenz-&gt;Drive(); Car* pBMW = new BMW; pBMW-&gt;Drive();&#125;class Car&#123;public: virtual void Drive()&#123;&#125;&#125;;//2.override 修饰派生类虚函数强制完成重写class Benz : public Car&#123;public: virtual void Drive()override &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125;&#125;; C++11 override和final另外补充一下的是C++11提供override和final来修饰虚函数 实际中我们建议多使用纯虚函数+override的方式来强制重写虚函数，因为虚函数的意义就是实现多态，如果没有重写，虚函数就没有意义 12345678910111213141516171819202122232425262728293031323334//1.final修饰基类的虚函数不能被派生类重写class Car&#123;public: virtual void Drive()final&#123;&#125;&#125;;class Benz : public Car&#123;public: virtual void Drive() &#123; virtual void Drive() &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125; &#125;&#125;;class Car&#123;public: virtual void Drive() &#123;&#125;&#125;;//2.override 修饰派生类虚函数强制完成重写，如果没有重写会编译报错class Benz : public Car&#123;public: virtual void Drive()override &#123; cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; &#125;&#125;; 多态的原理1234567891011class Base&#123;public: virtual void Func1() &#123; cout &lt;&lt; "Func()" &lt;&lt; endl; &#125; private: int _b = 1;&#125;; 通过观察测试我们发现b对象是8bytes，除了_b成员，还多一个_vfptr放在对象的前面(注意有些平台可能会放到对象的后面，这个跟平台有关)，对象中的这个指针我们叫做虚函数表指针(v代表virtual,f代表function)，一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，虚函数表也简称虚表，那么派生类中为什么要放这个表呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int main()&#123; Base b; return 0;&#125;//针对上面的代码我们做出以下改造//1.我们增加一个派生类Derive去继承Base//2.Derive中重写Func1//3.Base再增加一个虚函数Func2和一个普通函数Func1class Base&#123;public: virtual void Func1() &#123; cout &lt;&lt; "Base::Func1()" &lt;&lt; endl; &#125; virtual void Func2() &#123; cout &lt;&lt; "Base::Func2()" &lt;&lt; endl; &#125; void Func3() &#123; cout &lt;&lt; "Base::Func3()" &lt;&lt; endl; &#125; private: int _b = 1;&#125;;class Derive : public Base&#123;public: virtual void Func1() &#123; cout &lt;&lt; "Derive::Func1()" &lt;&lt; endl; &#125;private: int _d = 2;&#125;;int main()&#123; Base b; Derive d; return 0;&#125; 通过观察和测试，我们发现了以下问题： 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以虚函数的重写叫做覆盖，覆盖就是指虚表中虚函数的覆盖，重写是语法的叫法，覆盖是原理层的叫法 另外Func继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr 总结一下派生类的虚表生成: a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚标的最后 这里还有一个很容易混淆的问题：虚函数存在哪的?虚表存在哪的？答：虚函数存在虚表，虚表存在对象中，注意上面的回答是错误的。但是很多童鞋都是这样深以为然的。注意虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。那么虚表存在哪的呢？实际我们去验证一下会发现vs下是存在代码段的 多态的原理123456789101112131415161718192021222324252627282930313233class Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票-全价" &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: virtual void BuyTicket() &#123; cout &lt;&lt; "买票-半价" &lt;&lt; endl; &#125;&#125;;void Func(Person&amp; p)&#123; p.BuyTicket();&#125;int main()&#123; Person Mike; Func(Mike); Student Johnson; Func(Johnson); return 0;&#125; 11. 观察下面的红色箭头我们看到，p是指向mike对象时，p-&gt;BuyTicket在mike的虚表中找到虚函数是Person::BuyTicket 观察下图的蓝色箭头我们看到，p是指向johnson对象时，p-&gt;BuyTicket在johnson的虚表中找到虚函数是Student -&gt; BuyTicket. 这样就实现出不同对象去完成同一行为时，展现出不同形态 反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是对象的指针或引用调用虚函数 满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象中去找的，不满足多态的函数调用时编译时确认好的 12345678910111213void Func(Person* p)&#123; p-&gt;BuyTicket();&#125;int main()&#123; Person mike; Func(&amp;mike); mike.BuyTicket(); return 0;&#125; 动态绑定与静态绑定 静态绑定又称为前期绑定(早绑定),在程序编译期间确定了程序的行为，也称为静态多态，比如:函数重载 动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构]]></title>
    <url>%2F2019%2F04%2F27%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Linux目录结构和作用【常见目录说明】 目录 /bin 存放二进制可执行文件(ls,cat,mkdir等),常用命令一般都在这里 /etc 存放系统管理和配置文件 /home 存放所有用户文件的根目录 /usr 用于存放系统应用程序，比较重要的目录/usr/local本地系统管理员软件安装目录(安装系统级的应用)。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序/usr/sbin 超级用户的一些管理程序/usr/doc Linux文档/usr/include linux下开发和编译应用程序所需要的头文件/usr/lib 常用的动态链接库和软件包的配置文件/usr/man 帮助文档/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里/usr/local/bin 本地增加的命令/usr/local/lib 本地增加的库 /opt 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里 /proc 虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息 /root 超级用户(系统管理员)的主目录 /sbin 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序，如ifconfig等 /dev 用于存放设备文件 /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他文件系统 /boot 存放用于系统引导时使用的各种文件 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件 /tmp 用于存放各种临时文件，是公用的临时文件存储点 /var 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件(系统启动日志等) /lost+found 这个目录平时是空的，系统非正常关机而留下”无家可归”的文件在这里 Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图： 通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大多数文件都不需要经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。 etc文件系统/etc目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的man页。许多网络配置文件也在/etc中。 /etc/rc或/etc/rc.d或/etc/rc?.d启动、或改变运行级时运行的脚本或脚本的目录 /etc/passwd用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其他信息。 /etc/fdprm软盘参数表，用以说明不同的软盘格式。可用setfdprm进行设置。更多的信息见setfdprm /etc/fstab指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。 /etc/group类似/etc/passwd,但说明的不是用户信息而是组的信息。包括组的各种数据 /etc/inittabinit的配置文件 /etc/issue包括用户再登陆提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定 /etc/magic“file”的配置文件。包含不同文件格式的说明，”file”基于它猜测文件类型 /etc/motdmotd是message of the day的缩写，用户成功登录后自动输出，内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等 /etc/mtab当前安装的文件系统列表。由脚本(script)初始化，并由mount命令自动更新，当需要一个当前安装的文件系统的列表时使用(例如df命令) /etc/shadow在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困难，以此增加系统的安全性 /etc/login.defslogin命令的配置文件 /etc/printcap类似/etc/termcap,但针对打印机。语法不同 /etc/profile、/etc/csh.login、/etc/csh.cshrc登陆或启动时bourne或c.shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境 /etc/securetty确认安全终端，即哪个终端允许超级用户(root)登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权 /etc/shells列出可以使用的shell。chsh命令允许用户在本文件指定范围内改变登录的shell。提供一台机器ftp服务的服务进程ftpd检查用户shell是否列在/etc/shells文件中，如果不是，将不允许该用户登录 /etc/termcap终端性能数据库。说明不同的终端用什么”转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。 /dev文件系统/dev目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。设备文件在安装时由系统产生，以后可以用/dev/makedev描述。/dev/makedev.local是系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准makedev的一部分)。下面简要介绍/dev下一些常用文件。 /dev/console系统控制台，也就是直接和系统连接的监视器 /dev/hdide硬盘驱动程序接口。如:/dev/hda指的是第一个硬盘，had1则是指/dev/hda的第一个分区。如系统中有其他的硬盘，则依次为/dev/hdb、/dev/hdc、……;如有多个分区依次为hda1、hda2…… /dev/sdscsi硬盘驱动程序接口，如有系统有scsi硬盘，就不会访问/dev/hah,而会访问/dev/sda。 /dev/fd软驱设备驱动程序。如：/dev/fd0指系统的第一个软盘，也就是通常所说的a:盘，/dev/fd1指第二个软盘，……而/dev/fd1h1440则表示访问驱动器1中的4，5高密盘。 /dev/stscsi磁带驱动器驱动程序 /dev/tty提供虚拟控制台支持。如：/dev/tty1指的是系统的第一个虚拟控制台，/dev/tty2则是系统的第二个虚拟控制台 /dev/pty提供远程登录伪终端支持。在进行telnet登陆时需要用到 /dev/ttys计算机串行接口，对于dos来说就是”com1”口 /dev/cua计算机串行接口，与调制控制器一起食用的设备 /dev/null“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/dev/null中即可 /usr文件系统/usr是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr里的所有文件一般来自linux发行版(distribution)；本地安装的程序和其他东西在/usr/local下，因为这样可以在升级新版或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。 /usr/x11r6包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x win d o w系统感到束手无策了。 /usr/bin集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin或/usr/local/bin中 /usr/sbin包括了根文件系统不必要的系统管理命令，例如多数服务程序 /usr/include包含了c语言的头文件，这些文件多以.h结尾。用来表述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib下，但习惯上一直沿用了这个名字 /usr/lib包含了程序或子系统的不变的数据文件，包含一些site-wide配置文件。名字lib来源于库(library);编程的原始库也存在/usr/lib里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中 /usr/local本地安装的软件和其他文件放在这里。这与/usr很相似。用户可能会在这发现一些比较大的软件包，如tex、emacs等。 /var文件系统/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/ v a r目录中有些内容是在/ u s r中的，但为了保持/ u s r目录的相对稳定，就把那些需要经常改变的目录放到/ v a r中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。 /var/catman包括了格式化过的帮助(man)页。帮助页的源文件一般存在/usr/man/man中；有些man页可能有预格式化的版本，存在/usr/man/cat中。而其他的man页在第一次看时都需要格式化，格式化完的版本存在/var/man中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman经常被清除，就像清除临时目录一样) /var/lib存放系统正常运行时要改变的文件 /var/local存放/usr/local中安装的程序的可变数据(即系统管理员安装的程序)。注意：如果必要，即使本地安装的程序也会使用其他/var目录，例如/var/lock /var/lock锁定文件。许多程序遵循在/var/lock中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。 /var/log各种程序的日志(log)文件，尤其是login(/var/log/wtmp log记录所有到系统的登录和注销)和syslog(/var/log/message记录存储所有核心和系统程序信息)。/var/log里的文件经常不确定地增长，应该定期清除。 /var/run保存在下一次系统引导前有效的关于系统的信息文件。例如，/var/run/utmp包含当前登录的用户的信息 /var/tmp比/tmp允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp有很久的文件 /proc文件系统/proc文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系统的信息。 /proc/x关于进程x的信息目录，这里x是这一进程的标识号。每个进程在/proc下有一个名为自己进程号的目录 /proc/cpuinfo存放处理器(cpu)的信息，如cpu的类型、制造商、型号和性能等。 /proc/devices当前运行的核心配置的设备驱动的列表 /proc/dma显示当前使用的dma通道 /proc/filesystems核心配置的文件系统信息 /proc/interrupts显示被占用的中断信息和占用者的信息，以及被占用的数量 /proc/ioports当前使用的i/o接口 /proc/ksyms核心符号表 /proc/net网络协议状态信息 /proc/uptime系统启动的时间长度 /proc/version核心版本]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的概念及定义]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[继承的概念及定义继承的概念继承机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用 123456789101112131415161718192021222324252627282930313233343536class Person&#123;public: void Print() &#123; cout &lt;&lt; "name:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "age:" &lt;&lt; _age &lt;&lt; endl; &#125; protected: string _name = "Peter"; //姓名 int _age = 18; //年龄&#125;;//继承父类的Person的成员(成员函数+成员变量)都会变成子类的一部分，这里体现出了Student和Teacher复用了Person的成员，下面我们使用监视窗口查看Student和Teacher对象，可以看到变量的复用，调用Print可以看到成员函数的复用class Student : public Person&#123;protected: int _stuid;//学号&#125;;class Teacher : public Person&#123;protected: int _jobid; //工号&#125;;int main()&#123; Student s; Teacher t; s.Print(); t.Print(); return 0;&#125; 继承的定义定义格式 如上述代码所示，Person是父类，也称作基类。Student是子类，也称作派生类，public为继承方式 继承关系和访问限定符 继承方式： public继承 protected继承 private继承 访问限定符 public访问 protected访问 private访问 继承基类成员访问方式的变化 类成员/继承方式 public继承 protected继承 private继承 基类的public成员 派生类的public成员 派生类的protected成员 派生类的private成员 基类的protected成员 派生类的protected成员 派生类的protected成员 派生类的private成员 基类的private成员 在派生类中不可见 在派生类中不可见 在派生类中不可见 总结 基类的private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它 基类private成员在派生类中是不能被访问的，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected，可以看出保护成员限定符是因继承才出现的 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见的，基类的其它成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。 使用关键字class默认的继承方式是private，使用struct时默认继承方式是public，不过最好显式的写出继承方式 在实际运用中一般使用都是public继承，几乎很少使用protected/private继承，也不提倡使用protected/private继承，因为protected/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强 123456789101112131415161718192021//实例演示三种继承关系下基类成员的各类型成员访问关系的变化class Person&#123;public: void Print() &#123; cout &lt;&lt; _name &lt;&lt; endl; &#125;private: string _name; //姓名private: int _age; //年龄&#125;;//class Student : protected Person//class Student : private Personclass Student : public Person&#123;protected: int _stunum;//学号&#125;; 基类和派生类对象赋值转换 派生类对象可以赋值给基类的对象/基类的指针/基类的引用。这里有个形象的说法叫做切片或者切割，寓意把派生类中父类那部分切来赋值过去。 基类对象不能赋值给派生类对象 基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic cast来进行识别后进行安全转换。 父类对象不能赋值给子类对象，可能会造成访问异常 父类指针在特定条件下可以赋值给子类指针。如果父类指针本身指向的为子类对象的空间，赋值是安全的，否则，不安全 1234567891011121314151617181920212223242526272829303132class Person&#123;protected: string _name; //姓名 string _sex; //性别 int _age; //年龄&#125;;class Student : public Person&#123;public: int _No; //学号&#125;;void Test()&#123; Student sobj; // 1.子类对象可以赋值给父类对象/指针/引用 Person pobj = sobj; Person* pp = &amp;obj; Person&amp; rp = sobj; // 2.基类对象不能赋值给派生类对象 sobj = pobj; // 3.基类的指针可以通过强制类型转换赋值给派生类的指针 pp = &amp;sobj; Student* ps1 = (Student*)pp; //这种情况转换是可以的 ps1-&gt;_No = 10; pp = &amp;pobj; Student* ps2 = (Student*)pp; //这种情况转换时虽然可以，但是会存在越界访问的问题 ps2-&gt;_No = 10;&#125; 继承中的作用域 在继承体系中基类和派生类都有独立的作用域 子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫做隐藏，也叫重定义。(在子类成员函数中，可以使用 基类::基类成员 显式访问) 需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏 注意在实际中在继承体系里面最好不要定义同名的成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//student的_num和Person的_num构成隐藏关系，可以看出这样代码虽然能跑，但是非常容易混淆class Person&#123;protected: string _name = "张三"; //姓名 int _num = 111; //身份证号&#125;;class Student : public Person&#123;public: void Print() &#123; cout &lt;&lt; "姓名：" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "身份证号:" &lt;&lt; Person::_num &lt;&lt; endl; cout &lt;&lt; "学号：" &lt;&lt; _num &lt;&lt; endl; &#125;protected: int _num = 999; //学号&#125;;void Test()&#123; Student s1; s1.Print();&#125;//B中的fun和A中的fun不是构成重载，因为不是在同一作用域//B中的fun和A中的fun构成隐藏，成员函数满足函数名相同就构成隐藏class A&#123;public: void fun() &#123; cout &lt;&lt; "fun()" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void fun(int i) &#123; A::fun(); cout &lt;&lt; "func(int i)-&gt;" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;void Test()&#123; B b; b.fun(10);&#125; 派生类的默认成员函数6个默认成员函数，”默认“的意思是指我们不写，编译器会帮我们自动生成一个，那么在派生类中，这几个成员函数是如何生成的？ 1. 构造函数函数： - 默认生成的：首先会自动调用父类的构造函数，再调用自己的构造函数 - 显式定义的：如果父类有默认构造函数，不需要显式调用，如果父类没有默认构造函数，需要在初始化列表当中显式调用 2. 拷贝构造函数： - 默认生成的：编译器会自动调用父类的拷贝构造函数 - 显式定义的：如果不显示调用父类的拷贝构造，编译器会调用父类的默认构造 3. 赋值运算符重载函数 - 默认生成的：编译器会自动调用父类的赋值运算符重载函数 - 显式定义的：如果不显式调用父类的赋值运算符重载函数，编译器不会调用父类的任何成员函数 4. 析构函数 - 默认生成的：先执行自己的析构函数，编译器再调用父类的析构函数 - 显式定义的：不需要显式调用父类的析构函数，编译器会自动调用，注意父类的析构函数和子类的析构函数会构成函数隐藏 5. 取地址运算符重载函数：使用编译器默认生成的即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Person&#123;public: Person(const char* name = "Peter") :_name(name) &#123; cout &lt;&lt; "Person()" &lt;&lt; endl; &#125; Person(const Person&amp; p) :_name(p._name) &#123; cout &lt;&lt; "Person(const Person&amp; p)" &lt;&lt; endl; &#125; Person&amp; operator=(const Person&amp; p) &#123; cout &lt;&lt; "Person operator=(const Person&amp; p)" &lt;&lt; endl; if(this != &amp;p) &#123; _name = p._name; &#125; return *this; &#125; ~Person() &#123; cout &lt;&lt; "~Person()" &lt;&lt; endl; &#125;protected: string _name; //姓名&#125;;class Student : public Person&#123;public: Student(const char* name, int num) :Person(name) ,_num(num) &#123; cout &lt;&lt; "Student()" &lt;&lt; endl; &#125; Student(const Student&amp; s) :Person(s) ,_num(s._num) &#123; cout &lt;&lt; "Student(const Student&amp; s)" &lt;&lt; endl; &#125; Student&amp; operator=(const Student&amp; s) &#123; cout &lt;&lt; "Student&amp; operator=(const Student&amp; s)" &lt;&lt; endl; if(this != &amp;s) &#123; Person::operator = (s); _num = s._num; &#125; return *this; &#125; ~Student() &#123; cout &lt;&lt; "~Student()" &lt;&lt; endl; &#125;protected: int _num; //学号&#125;;void Test()&#123; Student s1("jack", 18); Student s2(s1); Student s3("rose", 17); s1 = s3;&#125; 继承与友元友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 12345678910111213141516171819202122232425262728class Student;class Person&#123;public: friend void Display(const Person&amp; p, const Student&amp; s);protected: string _name; //姓名&#125;;class Student : public Person&#123;protected: int _stuNum; //学号&#125;;void Display(const Person&amp; p, const Student&amp; s)&#123; cout &lt;&lt; p._name &lt;&lt; endl; cout &lt;&lt; s._stuNum &lt;&lt; endl;&#125;void main()&#123; Person p; Student s; Display(p, s);&#125; 继承与静态成员基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例。 123456789101112131415161718192021222324252627282930313233343536class Person&#123;public: Person() &#123; ++_count; &#125;protected: string _name; //姓名public: static int _count; //统计人数&#125;;int Person :: _count = 0;class Student : public Person&#123;protected: int _stuNum; //学号&#125;;class Graduate : public Student&#123;protected: string _seminarCourse; //研究科目&#125;;void TestPerson()&#123; Student s1; Student s2; Student s3; Graduate s4; cout &lt;&lt; "人数:" &lt;&lt; Person :: _count &lt;&lt; endl; cout &lt;&lt; "人数:" &lt;&lt; Person :: _count &lt;&lt; endl;&#125; 复杂的菱形继承及菱形虚拟继承单继承：一个子类只有一个直接父类时称这个继承关系为单继承 多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承 菱形继承：菱形继承是多继承的一种特殊情况 菱形集成的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。在Assistant的对象中Person成员会有两份 123456789101112131415161718192021222324252627282930313233class Person&#123;public: string _name; //姓名&#125;;class Student : public Person&#123;protected: int _num; //学号&#125;;class Teacher : public Person&#123;protected: int _id; //职工编号&#125;;class Assistant : public Student,public Teacher&#123;protected: string _majorCourse; //主修课程&#125;;void Test()&#123; //这样会有二义性无法明确知道访问的是哪一个 Assistand a; a._name = "Peter"; //需要显式指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决 a.Student::_name = "xxx"; a.Teacher::_name = "yyy";&#125; 虚拟继承可以解决菱形继承的二义性和数据冗余的问题，如上面的继承关系，在Student和Teacher的继承Person时使用虚拟继承，即可解决问题。需要注意的是，虚拟继承不要在其他地方去使用 1234567891011121314151617181920212223242526272829class Person&#123;public: string _name; //姓名&#125;;class Student : virtual public Person&#123;protected: int _num; //学号&#125;;class Teacher : virtual public Person&#123;protected: int _id; //职工编号&#125;;class Assistant : public Student,public Teacher&#123;protected: string _majorCourse; //主修课程&#125;;void Test()&#123; Assistant a; a,_name = "Peter";&#125; 虚拟继承解决数据冗余和二义性的原理 12345678910111213141516171819202122232425262728293031323334353637class A&#123;public: int _a;&#125;;//class B : public Aclass B : virtual public A&#123;public: int _b;&#125;;//class C : public Aclass C : virtual public A&#123;public: int _c;&#125;;class D : public B, public C&#123;public: int _d;&#125;;int main()&#123; D d; d.B::_a = 1; d.C::_a = 2; d._b = 3; d._c = 4; d._d = 5; return 0;&#125; 继承的总结和反思 C++语法复杂，多继承就是一个体现，有了多继承,就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂，所以一般不建议设计出多继承，一定不要设计出菱形继承，否则在复杂度及性能上都有问题 多继承可以认为是C++的缺陷之一，后来很多语言都没有多继承，如java。 继承和组合 public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。 组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。 优先使用对象组合，而不是类继承 继承允许你根据基类的实现来定义派生类的实现，这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。”白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以”黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。 实际尽量多去用组合。组合的耦合度低，代码维护型好。不过继承也有用武之地的，有些关系适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。 123456789101112131415161718192021222324252627282930313233343536373839404142//Car和BMW Car和Benz构成is-a的关系class Car&#123;protected: string _colour = "白色"; //颜色 string _num = "陕A12345"; //车牌号&#125;;class BMW : public Car&#123;public: void Drive() &#123; cout &lt;&lt; "操控好" &lt;&lt; endl; &#125;&#125;;class Benz : public Car&#123;public: void Drive() &#123; cout &lt;&lt; "舒适" &lt;&lt; endl; &#125;&#125;;//Tire和Car构成has-a的关系class Tire&#123;protected: string _brand = "Michelin"; //品牌为米其林 size_t size = 19; //规格为19寸轮毂&#125;;class Car&#123;protected: string _colour = "白色"; //颜色 string _num = "陕A12345"; //车牌号 Tire _t; //轮胎&#125;;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux是什么及其常见指令]]></title>
    <url>%2F2019%2F04%2F22%2FLinux%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux是什么Linux是一个操作系统内核（操作系统 =&gt; 内核 + 一组配套的应用程序），而内核是用来负责对于软件资源和硬件设备的管理。 Linux发行版：CentOs,Android,Ubuntu,Debain,Kali,Mint …… Redhat(大部分公司中使用的发行版) Xshell:远程终端程序 Linux：全世界市场份额最高的操作系统，任何一名程序员都会用到的操作系统 1. 移动端领域（安卓） 2. 服务器领域（90%的服务器都用Linux） 3. 嵌入式领域 4. 桌面领域（Linux在桌面领域表现不佳） Linux下基本指令 ls指令 语法：ls 【选项】【目录或文件】 功能：对于目录，该命令列出该目录下的所有子目录与文件，对于文件，将列出文件名以及其他信息。 常用选项 -a 列出目录下的所有文件，包括以.开头的隐藏文件 -d 将目录像文件一样显示，而不是显示其下的文件。如：ls -d 指定目录 -i 输出文件的i节点的索引信息。如ls -ai 指定文件 -k 以k字节的形式表示文件的大小。ls -alk指定文件 -l 列出文件的详细信息 -n 用数字的UID,GID代替名称。 -F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字（socket）。（目录类型识别） -r 对目录反向排序 -t 以时间排序 -R 列出所有子目录下的文件。（递归） -1 一行只输出一个文件 pwd命令 语法：pwd 功能：显示用户当前所在的目录 cd指令 语法：cd 目录名 功能： 改变工作目录。将当前工作目录改变到指定的目录下 举例： cd .. ：返回上级目录 cd /home/hanhaodong/My_code/: 绝对路径 cd ../Linux/: 相对路径 (谈到相对路径，必须明确当前路径) cd~:进入用户的home目录 cd-：返回最近访问目录 touch指令 语法：touch [选项]… 文件… 功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的空文件。 常用选项 -a 或 –time=atime或–time=access或–time=use只更改存取时间 -c 或-no-create 不建立任何文档 -d 使用指定的日期时间，而非现在的时间 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题 -m 或–time=mtime或–time=modify 只更改变动时间 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同 -t 使用指定的日期时间，而非现在的时间 mkdir指令 语法：mkdir [选项] dirname 功能：在当前目录下创建一个名为”dirname”的目录 常用选项： -p,–parents 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录 rmdir指令&amp;&amp;rm指令 rmdir是一个与mkdir相对应的命令，mkdir是建立目录，而rmdir是删除命令 语法：rmdir [-p][dirName] 适用对象：具有当前目录操作仅限的所有使用者 功能：删除空目录 常用选项： -p 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除 rm命令可以同时删除文件或目录 语法： rm [-f -i -r -v][dirName/dir] 适用对象：所有使用者 功能：删除文件或目录 常用选项： -f 即使文件属性为只读(即写保护)，亦直接删除 -i 删除前逐一询问确认 -r 删除目录及其下所有文件 man指令（重要） Linux的命令有很多参数，我们可以通过查看联机手册获取帮助。访问Linux手册页的命令时man 语法：man [选项] 命令 常用选项： -k 根据关键字搜索联机帮助 num 只在第num章节找 -a 将所有章节的都显示出来，比如man printf 它缺省从第一章开始搜素，知道就停止，用a选项，当按下q退出，他会继续往后面搜索，直到所有章节都搜索完毕 man手册分为八章： 1. 是普通命令 2. 是系统调用，如open，write之类 3. 是库函数，如printf,fread4是特殊文件，也就是/dev下的各种设备文件 4. 是指文件的格式，比如passwd，就会说明这个文件中各个字段的含义 5. 是给游戏留用，由各个游戏自己定义 6. 是附件还有一些变量，比如像environ这种全局变量在这里就有说明 7. 是系统管理用的命令，这些命令只能由root使用，如ifconfig cp指令 语法： cp [选项] 原文件或目录 目标文件或目录 功能：复制文件或目录 说明：cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息 常用选项： -f 或 -force强行复制文件或目录，不论目的文件或目录是否已经存在 -i 或 -interactive 覆盖文件之前先询问用户 -r 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理 -R 或 -recursive递归处理，将指定目录下的文件及子目录一并处理 mv指令 mv命令是move的缩写，可以用来移动文件或者将文件改名(move (rename) files)，是Linux系统下常用的命令，经常用来备份文件或者目录 语法：mv [选项] 源文件或目录 目标文件或目录 功能： 视mv命令中第二个参数类型的不同(是目标文件还是目标目录)，mv命令将文件重命名或将其移至一个新的目录中 当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个(也可以是源目录名)，它将所给的源文件或目录重命名为给定的目标文件名 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中 常用选项 -f : force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i : 若目标文件(destination)已经存在时，就会询问是否覆盖！ cat 语法：cat [选项][文件] 功能：查看目标文件的内容 常用选项： -b 对非空输出行编号 -n 对输出的所有行编号 -s 不输出多行空行 less指令 less工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大 less的用法比起more更加的有弹性。在more的时候，我们并没有办法向前面翻，只能往后面看 但若使用了less时，就可以使用 [pageup][pagedown]等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容 除此之外，在less里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜 语法：less [参数] 文件 功能： less与more相似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件，而大部分编辑器都是直接把整个文件都加载(延时加载/懒加载) 选项： -i 忽略搜索时的大小写 -N 显示每行的行号 /字符串：向下搜索”字符串”的功能 ?字符串：向上搜索”字符串”的功能 n: 重复前一个搜索(与/或?有关) N：反向重复前一个搜索(与/或?有关) q:quit 时间相关的指令 date显示 date指定格式显示时间：date +%Y:%m:%d date用法：date [OPTION]…[+FORMAT] 在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下 %H: 小时(00…23) %M: 分钟(00…59) %S: 秒(00..61) %X: 相当于 %H:%M:%S %d: 日(01…31) %m: 月份(01…12) %Y: 完整年份(0000…9999) %F: 相当于 %Y-%m-%d 在设定时间方面 date -s //设置当前时间，只有root权限才能设置，其它只能查看 date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00 date -s 01:01:01 //设置具体时间，不会对日期做更改 date -s “01:01:01 2008-5-23” //这样可以设置全部时间 date -s “01:01:01 20080523” //这样可以设置全部时间 date -s “2008-5-23 01:01:01” //这样可以设置全部时间 date -s “20080523 01:01:01” //这样可以设置全部时间 时间戳 时间 -&gt; 时间戳: date +%s 时间戳 -&gt; 时间: date -d@1558749502 Unix时间戳(英文为Unix epoch,Unix time,POSIX time 或 Unix timestamp) 是从1970年1月1日(UTC/GMT的午夜)开始所经过的秒数，不考虑闰秒 find指令： -name Linux下find命令在目录结构中搜素文件，并执行指定的操作 Linux下find命令提供了相当多的查找条件，功能很强大，由于find具有强大的功能，所以它的选项也很多 即使系统中含有网络文件系统(NFS),find命令在该文件系统中同样有效，只要你具有相应的权限 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(指30G字节以上的文件系统) 语法：find pathname -options 功能：用于在文件树种查找文件，并作出相应的处理(可能访问磁盘) 常用选项： -name 按照文件名查找文件 grep指令 语法：grep [选项]搜寻字符串文件 功能：在文件中搜索字符串，将找到的行打印出来 常用选项： -i :忽略大小写的不同，所以大小写视为相同 -n：顺便输出行号 -v: 反向选择，亦即显示出没有’搜寻字符串’内容的那一行]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string类]]></title>
    <url>%2F2019%2F04%2F20%2Fstring%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[标准库中的string类 字符串是表示字符序列的类 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 string类是使用char（即作为它的字符类型，使用它的默认char_traits和分配器类型）。 string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数。 注意，这个类独立于所使用的编码来处理字节：如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。总结: string是表示字符串的字符串类 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作 string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char,char_traits,allocator&gt;string; 不能操作多字节或者变长字符的序列 在使用string类时，必须包含头文件以及using namespace std; string类的常用接口说明1. string类对象的常见构造 函数名称 功能说明 string() 构造空的string类对象，即空字符串 string(const char* s) 用C-string来构造string类对象 string(size_t n, char c) string类对象中包含n个字符c string(const string&amp; s) 拷贝构造函数 string(const string&amp; s, size_t n) 用s中的前n个字符构造新的string类对象 12345678void TestString()&#123; string s1; //构造空的string类对象s1 string s2(&quot;hello world&quot;); //用C格式字符串构造string类对象s2 string s3(10,&apos;a&apos;); //用10个字符&apos;a&apos;构造string类对象s3 string s4(s2); //拷贝构造s4 string s5(s3, 5); //用s3中前5个字符构造string对象s5&#125; 2. string类对象的容量操作 函数名称 功能说明 size_t size()const 返回字符串有效字符长度 size_t length()const 返回字符串有效字符长度 size_t capacity()const 返回空间总大小 bool empty()const 检测字符串是否为空串，是返回true,否则返回false void clear() 清空有效字符 void resize(size_t n,char c) 将有效字符的个数改成n个，多出的空间用字符c填充 void resize(size_t n) 将有效字符的个数改成n个，多出的空间用0填充 void reserve(size_t res_arg = 0) 为字符串预留空间 【注意】 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 clear()只是将string中有效字符清空,不改变底层空间大小。 reserve(size_t n)与resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时，reserve(n)用0来填充多出的元素空间，reserve(size_t n, char c)用字符c来填充多出的元素空间。注意: resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 reserve(size_t res, arg = 0): 为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小。 3.string类对象的访问操作 函数名称 功能说明 char&amp; operator 返回pos位置的字符，const string类对象调用 const char&amp; operator const 返回pos位置的字符，非const string类对象调用 1234567891011121314151617void TestString()&#123; String s1(&quot;hello world&quot;); const String s2(&quot;hello world&quot;); cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s1[0] &lt;&lt; &quot; &quot; &lt;&lt; s2[0] &lt;&lt; endl; s1[0] = &apos;H&apos;; cout &lt;&lt; s1 &lt;&lt; endl; for(size_t i = 0; i &lt; s1.size(); ++i) &#123; cout &lt;&lt; s1[i] &lt;&lt; endl; &#125; //s2[0] = &apos;h&apos;; 代码编译失败，因为const类型对象不能修改&#125; 4.string类对象的修改操作 函数名称 功能说明 void push_back(char c) 在字符串后尾插字符c string&amp; append(const char* s) 在字符串后追加一个字符串 string&amp; operator+=(const string&amp; str) 在字符串后追加字符串str string&amp; operator+=(char c) 在字符串后追加字符c const char* c_str()const 返回C格式字符串 size_t find(char c, size_t pos = 0) const 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置 size_t rfind(char c, size_t pos = npos) 从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置 string substr(size_t pos = 0, size_t n = npos) const 在str中从pos位置开始，截取n个字符，然后将其返回 【注意】 在string尾部追加字符时,s.push_back(a)/s.append(1,a)/s += ‘a’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预备好。 5.string类非成员函数 函数 功能说明 operator+ 尽量少用，因为效率低 operator&gt;&gt; 输入运算符重载 operator&lt;&lt; 输出运算符重载 getline 获取一行字符串 relational operators 大小比较]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数模板、类模板]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1.泛型编程怎样去实现一个通用的交换函数呢？ 12345678910111213141516171819202122void Swap(int&amp; left, int&amp; right)&#123; int temp = left; left = right; right = tmp;&#125;void Swap(double&amp; left, double&amp; right)&#123; double temp = left; left = right; right = temp;&#125;void Swap(char&amp; left, char&amp; right)&#123; char temp = left; left = right; right = temp;&#125;...... 使用函数重载虽然可以实现，但是有以下几个不好的地方 重载的函数仅仅只是类型不同，代码复用率较低，只要有新类型出现时，就需要增加时对应的函数 代码的可维护性比较低，一个出错可能所有的重载均出错 那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？ 泛型编程：编写与类型无关的通用代码，是代码复用的一种手段，模板是泛型编程的基础 2.函数模板2.1 函数模板概念函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本2.2 函数模板格式template返回值类型 函数名（参数列表）{} 1234567template&lt;typename T&gt;void Swap(T&amp; left, T&amp; right)&#123; T temp = left; left = right; right = temp;&#125; 注意：typename是用来定义模板参数的关键字，也可以使用class（切记，不能使用struct代替class）2.3 函数模板的原理模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具，所以其实模板就是将本来应该我们做的重复的事情交给了编译器在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用，比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。2.4 函数模板的实例化用不同类型的参数使用函数模板时，称为函数模板的实例化，模板参数实例化分为：隐式实例化和显式实例化 隐式实例化：让编译器根据实参推演模板参数的实际类型 123456789101112131415161718192021222324252627template&lt;class T&gt;T Add(const T&amp; left, const T&amp; right)&#123; return left + right;&#125;int main()&#123; int a1 = 10, a2 = 20; double d1 = 10.0, d2 = 20.0; Add(a1, a2); Add(d1, d2);/* Add(a1, d1); 该语句不能通过编译， 因为在编译期间， 当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参的d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int或者double类型而报错注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出现问题，编译器就需要背黑锅*///此时有两种处理方式：1.用户自己来强制转化 2.使用显式实例化 Add(a, (int)d); return 0;&#125; 显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型 123456789int main(void)&#123; int a = 10; double b = 20.0; //显式实例化 Add&lt;int&gt;(a, b); return 0;&#125; 如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。 2.5模板参数的匹配规则 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数 123456789101112131415161718//专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;//通用加法函数template&lt;class T&gt;T Add(T left, T right)&#123; return left + right;&#125;void Test()&#123; Add(1,2); //与非模板函数匹配，编译器不需要特化 Add&lt;int&gt;(1,2);//调用编译器特化的Add版本&#125; 对于非模板函数和同名函数模板，如果其他条件都相同，在调用时会优先调用非模板函数而不会从该模板产生出一个实例，如果模板可以产生一个具有良好匹配的函数，那么将选择模板 123456789101112131415161718//专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;//通用加法函数template&lt;class T1, class T2&gt;T1 Add(T1 left, T2 right)&#123; return left + right;&#125;void Test()&#123; Add(1, 2); //与非函数模板类型完全匹配，不需要函数模板实例化 Add(1, 2.0); //模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数&#125; 模板函数不允许自动类型转换，但普通函数可以进行自动类型转换3.类模板3.1 类模板的定义格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758template&lt;class T1,class T2,......,class Tn&gt;class 类模板名&#123; //类内容定义&#125;;//动态顺序表template&lt;class T&gt;class Vector&#123;public: Vector(size_t capacity = 10) :_pData(new T[capacity]) ,_size(0) ,_capacity(capacity) &#123;&#125; //使用析构函数演示，在类中声明，在类外定义。 ~Vector(); void PushBack(const T&amp; data) &#123; //_CheckCapacity(); _pData[_size++] = data; &#125; void PopBack() &#123; --_size; &#125; size_t Size() &#123; return _size; &#125; T&amp; operator[](size_t pos) &#123; assert(pos &lt; _size); return _pData[pos]; &#125; private: T* _pData; size_t _size; size_t _capacity;&#125;;//注意：类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;Vector&lt;T&gt;::~Vector()&#123; if(_pData) &#123; delete[] _pData; &#125;&#125; 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具 3.2类模板的实例化类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;,然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类 12345678910111213141516171819202122//Vector类名，Vector&lt;int&gt;才是类型Vector&lt;int&gt; s1;s1.PushBack(1);s1.PushBack(2);s1.PushBack(3);Vector&lt;double&gt; s2;s2.PushBack(1.0);s2.PushBack(2.0);s2.PushBack(3.0);for(size_t i = 0;i &lt; s1.size(); ++i)&#123; cout &lt;&lt; s1[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for(size_t i = 0; i &lt; s1.size() ; ++i)&#123; cout &lt;&lt; s2[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2F2019%2F04%2F18%2FC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.C/C++内存分布【说明】 栈又叫堆栈，非静态局部变量/函数参数/返回值等，栈是向下增长的。 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享内存，做进程间通信。 堆用于程序运行时动态内存分配，堆是可以向上增长的。 数据段-存储全局数据和静态数据。 代码段-可执行的代码/只读常量。2.C语言中动态内存管理方式2.1 malloc/calloc/realloc和free 12345678910void Test()&#123; int *p1 = (int*)malloc(sizeof(int)); free(p1); int* p2 = (int*)calloc(4, sizeof(int)); int* p3 = (int*)realloc(p2, sizeof(int)*10); free(p3);&#125; 3.C++内存管理方式C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式，通过new和delete操作符进行动态内存管理。3.1 new/delete 操作内置类型 12345678910111213141516void Test()&#123; //动态申请一个int类型的空间 int* ptr4 = new int; //动态申请一个int类型的空间并初始化为10 int* ptr5 = new int(10); //动态申请10个int类型的空间 int ptr6 = new int[10]; delete ptr4; delete ptr5; delete[] ptr6; //注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]&#125; 3.2 new和delete操作自定义类型 123456789101112131415161718192021222324252627class Test&#123;public: Test() :_data(0) &#123; cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl; &#125;private: int _data;&#125;;void Test()&#123; //申请单个Test类型的对象 Test* p1 = new Test; delete p1; //申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2;&#125; 【注意】：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc和free不会。 4. operator new与operator delete函数new和delete是用户进行动态内存申请和释放的操作符，operator new和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete底层通过operator delete全局函数来释放空间 1234567891011121314151617181920/*operator new: 该函数实际通过malloc来申请空间，当malloc&apos;申请空间成功时直接返回；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常*/void *_CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)&#123; //try to allocate size bytes void *p; while((p == malloc(size)) == 0) if(_callnewh(size) == 0) &#123; // report no memory //如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); &#125; return (p);&#125; operator new实际也是通过malloc来申请空间，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete最终是通过free来释放空间的 下面代码演示了，针对链表的节点ListNode通过重载类专属operator new/operator delete,实现链表节点使用内存池申请和释放内存，提高效率. 1234567891011121314151617181920struct LlistNode&#123; ListNode* _next; ListNode* _prev; int _data; void* operator new(size_t n) &#123; void* p = nullptr; p = allocator&lt;ListNode&gt;().allocate(1); cout &lt;&lt; &quot;memory pool allocate&quot; &lt;&lt; endl; return p; &#125; void operator delete(void* p) &#123; allocator&lt;ListNode&gt;().deallocate((ListNode*)p, 1); cout &lt;&lt; &quot;memory pool deallocate&quot; &lt;&lt; endl; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334class List&#123;public: List() &#123; _head = new ListNode; _head-&gt;next = _head; _head-&gt;prev = _head; &#125; ~List() &#123; ListNode* cur = _head-&gt;next; while(cur != _head) &#123; ListNode* next = cur-&gt;_next; delete cur; cur = next; &#125; delete _head; _head = nullptr; &#125;private: ListNode* _head;&#125;;int main()&#123; List l; return 0;&#125; 5.new和delete的实现原理5.1 内置类型如果申请的是内置类型空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时就会抛异常，malloc会返回NULL。5.2 自定义类型 new的原理 1. 调用operator new函数申请空间 2. 在申请的空间上执行构造函数，完成对象的构造 delete的原理 1. 在空间上执行析构函数，完成对象中的资源清理工作 2. 调用operator delete函数释放对象的空间 new T[N]的原理 1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请 2. 在申请的空间上执行N此构造函数 delete[]的原理 1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间 6. 内存泄漏6.1 什么是内存泄漏内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄露并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费 123456789101112void MemoryLeaks()&#123; // 1.内存申请了忘记释放 int *p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p2 = new int[10]; Func(); // 这里Func函数抛异常导致delete[] p3未执行，p3没有被释放 delete[] p3;&#125; 6.2 内存泄漏分类 堆内存泄漏（Heap leak） 堆内存指的是程序执行中依据须要分配通过malloc/calloc/realloc/new等从堆中分配的一块内存，用完后必须通过调用相应的free或delete删掉，加入程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生内存泄漏。 系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 6.3 如何避免内存泄漏 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps: 这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出现问题。需要下一条智能指针来管理才有保证。 采用RAII思想或者只能指针来管理资源。 有些公司内部规范使用内部实现的私有内存管理库，这套库自带内存泄漏检测的功能选项。 出问题了使用内存泄漏工具检测。ps: 不过很多工具都不够靠谱，或者收费昂贵。 【总结】内存泄漏非常常见，解决方案分为两种：1.事先预防型，如智能指针等。2.事后查错型。如泄漏检测工具。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解static、内部类、友元函数]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%90%86%E8%A7%A3static%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 再谈构造函数1.1 构造函数体赋值在创建对象时，编译器通过调用构造函数，给对象各个成员变量一个合适的初始值 123456789101112131415class Date&#123;public: Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; private: int _year; int _month; int _day;&#125;; 虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造函数体中的语句只能将其称作为赋初值，而不能称作初始化，因为初始化只能初始化一次，而构造函数体内可以多次赋值。 1.2 初始化列表初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个成员变量后面跟一个放在括号中的初始值或表达式 1234567891011121314class Date&#123;public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125;private: int _year; int _month; int _day;&#125;; 【注意】 1.每个成员变量在初始化列表中只能出现一次（初始化只能出现一次） 2.类中包含以下成员，必须放在初始化列表位置进行初始化： 引用成员变量 const成员变量 类类型成员变量（该类没有默认构造函数）12345678910111213141516171819202122class A&#123;public: A(int a) :_a(a) &#123;&#125;private: int _a;&#125;;class B&#123;public: B(int a, int ref) :_aobj(a) ,_ref(ref) ,_n(10) &#123;&#125;private: A _aobj; //没有默认构造函数 int&amp; ref; //引用 const int _n; //const&#125;; 尽量使用初始化列表初始化， 因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。 123456789101112131415161718192021222324252627class Time&#123;public: Time(int hour = 0) :_hour(hour) &#123; cout &lt;&lt; &quot;Time()&quot; &lt;&lt; endl; &#125;private: int _hour;&#125;;class Date&#123;public: Date(int day) &#123;&#125;private: int _day; Time _t;&#125;;int main()&#123; Date d(1);&#125; 4.成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关 1234567891011class Array&#123;public: Array(int size) :_size(size) ,_array((int*)malloc(sizeof(int)*_size)) &#123;&#125;private: int* _array; int _size;&#125; 1.3 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用 12345678910111213141516171819202122class Date&#123;public: Date(int year) :_year(year) &#123;&#125; explicit Date(int year) :_year(year) &#123;&#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1(2018); //用一个整型变量给日期类型对象赋值 //实际编译器背后会用2019构造一个无名对象， 最后用无名对象给d1对象进行赋值 d1 = 2019;&#125; 上述代码可读性不是很好，用explicit修是构造函数，将会禁止单参构造函数的隐式转换。 2.static成员2.1 概念声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量;用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化 面试题：实现一个类，计算程序中创建出了多少个类对象。 12345678910111213141516171819202122class A&#123;public: A() &#123;++_scount;&#125; A(const A&amp; t) &#123;++_scount;&#125; static int GetACount() &#123;return _scount;&#125;private: static int _scount;&#125;;int Test::_count = 0;void TestA()&#123; cout &lt;&lt; A::GetACount() &lt;&lt; endl; A a1, a2; A a3(a1); cout &lt;&lt; A:: GetACount() &lt;&lt; endl;&#125; 2.2 特性 1.静态成员为所有类对象所共享，不属于某个具体的实例 2.静态成员变量必须在类外定义，定义时不添加static关键字 3.类静态成员即可用类名::静态成员或者对象。静态成员来访问 4.静态成员函数没有隐藏的this指针，不能访问任何非静态成员 5.静态成员和类的普通成员一样，也是public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数。 3.C++的成员初始化新用法c++支持非静态成员变量在声明时，直接初始化 123456789101112131415161718192021222324252627282930313233343536class B&#123;public: B(int b = 0) :_b(b) &#123;&#125; int _b;&#125;;class A&#123;public: void Print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b._b &lt;&lt;endl; cout &lt;&lt; p &lt;&lt; endl; &#125;private: //非静态成员变量，可以在成员声明时，直接初始化 int a = 10; B b = 20; int* p = (int*)malloc(4); static int n; &#125;;int A::n = 10;int main()&#123; A a; a.Print(); return 0;&#125; 4.友元友元分为： 友元函数和友元类友元提供了一种突破封装的方式，有时提供了便利，但是友元会增加耦合度，破坏了封装，所以友元不宜多用。4.1 友元函数问题：现在我们尝试去重载operate&lt;&lt;，然后发现我们没办法将operate&lt;&lt;重载成成员函数。因为cout输出流对象和隐含的this指针抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。 1234567891011121314151617181920212223242526class Date&#123;public: Date(int year, int month,int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125; ostream&amp; operator&lt;&lt;(ostream&amp; _cout) &#123; _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d(2018, 12, 24); d &lt;&lt; cout; return 0;&#125; 友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。 12345678910111213141516171819202122232425262728293031323334353637class Date&#123;friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);friend istream&amp; operator&gt;&gt;(istream&amp; _cin,const Date&amp; d);public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125;private: int _year; int _month; int _day;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)&#123; _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout;&#125;istream&amp; operator&gt;&gt;(istream&amp; _cin, const Date&amp; d)&#123; _cin &gt;&gt; d._year; _cin &gt;&gt; d._month; _cin &gt;&gt; d._day; return _cin;&#125;int main()&#123; Date d; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 说明： 友元函数可以访问类的私有成员，但不是类的成员函数 友元函数不能用const修饰 友元函数可以在类定义的任何地方声明，不受访问限定符限制 一个函数可以是多个类的友元函数 友元函数的调用与普通函数的调用和原理相同 4.2 友元类友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员 友元函数是单向的，不具有交换性比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行 友元关系不能传递如果B是A的友元，C是B的友元，则不能说明C是A的友元 12345678910111213141516171819202122232425262728293031323334353637383940class Date; //前置声明class Time&#123; friend class Date; //声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量public: Time(int hour, int minute, int second) : _hour(hour) , _minute(minute) ,_second(second) &#123;&#125;private: int _hour; int _minute; int _second;&#125;;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1) : _year(year) , _month(month) , _day(day) &#123;&#125; void SetTimeOfDate(int hour, int minute, int second) &#123; //直接访问时间类私有的成员变量 _t._hour = hour; _t._minute = minute; _t._second = second; &#125;private: int _year; int _month; int _day; Time _t;&#125;; 5.内部类5.1 概念及特性概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类，外部类对内部类没有任何优越的访问权限。注意：内部类就是外部类的友元类。注意友元类的定义。内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。 特性： 内部类可以定义在外部类的public、projected、private都是可以的。 注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 sizeof(外部类) = 外部类，和内部类没有任何关系。 1234567891011121314151617181920212223242526class A&#123;private: static int k; int h;public: class B &#123; public: void foo(const A&amp; a) &#123; cout &lt;&lt; k &lt;&lt; endl; //OK cout &lt;&lt; a.h &lt;&lt; endl; //OK &#125; &#125;;&#125;;int A::k = 1;int main()&#123; A::B b; b.foo(A()); return 0;&#125; 6.再次理解封装c++是基于面向对象的程序，面向对象有三大特性即： 封装、继承、多态。 c++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起；通过访问限定符选择性的将其部分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让整个事情复杂化。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的六个默认成员函数如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并非如此，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。class Date {}; 1.构造函数·1.1 概念 构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。1.2 特性 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称是构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。 其特征如下： 1.函数名与类名相同 2.无返回值 3.对象实例化时编译器自动调用对应的构造函数 4.构造函数可以重载 12345678910111213141516171819202122232425262728class Date&#123;public: //1.无参构造函数 Date() &#123;&#125; //2.带参构造函数 Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1;//调用无参构造函数 Date d2(2015, 1, 1);//调用带参构造函数 //注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明 //以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象 Date d3();&#125; 5.如果类中没有显式定义构造函数，则c++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。6.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个，注意：无参构造函数，全缺省构造函数，我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。7.c++把类型分成内置类型（基本类型）和自定义类型。内置类型就是语法已经定义好的类型：如 int/char….，自定义类型就是我们使用class/struct/union自己定义的类型，编译器生成的默认构造函数会调用自定义类型的默认构造函数. 2.析构函数2.1 概念析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的，而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。2.2 特性析构是特殊的成员函数。特征如下：1.析构函数名是在类名前加上字符~2.无参数无返回值3.一个类有且只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数4.对象生命周期结束时，c++编译系统系统自动调用析构函数5.编译器生成的默认析构函数，对会自定类型成员调用它的析构函数 3.拷贝构造函数3.1 概念构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），再用已存在的类类型对象创建新对象时由编译器自动调用。3.2 特征1.拷贝构造函数是构造函数的一个重载形式2.拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式对引发无穷递归调用 12345678910111213141516171819202122232425262728class Date&#123; Date(int _year = 1900, int _month = 1,int _day = 1) &#123; _year = year; _month = month; _day = day; &#125; Date(const Date&amp; d) &#123; _year = d.year; _month = d.month; _day = d.day; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1; Date d2(d1); return 0;&#125; 3.若未显式定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝。 4.赋值运算符重载4.1 运算符重载c++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型operator操作符（参数列表）注意：1.不能通过连接其他符号来创建新的操作符：比如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，例如：内置的类型+，不能改变其含义。4.作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参5.、::、sizeof、？:、.注意以上五个运算符不能重载。5.2 赋值运算符重载赋值运算符主要有四点：1.参数类型2.返回值3.检测是否自己给自己赋值4.返回this5.一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝 6.const成员6.1 const修饰类的成员函数将const修饰的类的成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。6.2 有以下需要注意的点1.const对象不可以调用非const成员函数2.非const对象可以调用const成员函数3.const成员函数内不可以调用其他的非const成员函数4.非const成员函数内可以调用其它的const成员函数 7.取地址及const取地址操作符重载123456789101112131415161718这两个默认成员函数一般不用重新定义，编译器默认会生成class Date&#123;public: Date* operator&amp;() &#123; return this; &#125; const Date* operator&amp;()const &#123; return this; &#125; private: int _year; int _monthl int _day;&#125;; 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载比如想让别人获取到指定的内容！]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The_first_blog]]></title>
    <url>%2F2019%2F04%2F04%2FThe-first-blog%2F</url>
    <content type="text"><![CDATA[C++基础相关知识一.命名空间在c/c++中，变量、函数、类都是大量存在的，这些函数、变量和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或命名污染，namespace关键字的出现就是为了避免这种问题。 //1.普通的命名空间 namespace N1 //N1为命名空间的名称 { //命名空间的内容，可以定义变量，也可以定义函数 int a; int Add(int left , int right) { return left + right; } } //2.命名空间可以嵌套 namespace N2 { int a; int b; int Add(int left , int left) { return left + right; } namespace N3 { int c; int d; int sub( int left,int right ) { return left - right; } } } //3.同一个工程中允许存在多个相同名称的命名空间 // 编译器最终会合成同一个命名空间中 namespace N1 { int Mul(int left , int right) { return left*right; } } 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限与该命名空间中 二.c++输入&amp;输出12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello world!!&quot;&lt;&lt;endl; return 0;] 1.使用cout标准输出（控制台）和cin标准输入（键盘）时，必须包含头文件以及std标准命名空间。 注意：早期标准库将所有功能在全局域中实现，声明在.h后面的头文件中，使用时只需包含对应头文 件即可，后来将其实现在std命名空间下，为了和c头文件区分，也为了正确使用命名空间，规定 c++头文件不带.h;旧编译器（vc 6.0）中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐 使用+std的方式。 2.使用c++输入输出更方便，不需增加数据结构的控制。比如：整型-%d，字符-%c。 三. 缺省参数概念：缺省参数就是声明或定义时为函数的参数指定一个默认值。在调用函数时，如果没有指定实参则采用该默认值，否则使用指定实参。 12345678910void TestFunc(int a = 0)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;int main()&#123; TestFunc();//没有传参时，使用参数的默认值 TestFunc(10);//传参时使用指定实参&#125; 参数缺省分类全缺省参数: 123456void TestFunc(int a = 10,int b = 20, int c = 30)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 半缺省参数 1234567void TestFunc(int a, int b = 10,int c = 20)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 注意： 1.半缺省参数必须从右往左依次来给出，不能间隔着来给 2.缺省参数不能在函数声明和定义时同时出现。 123456//a.hvoid TestFunc(int a = 10);//a.cvoid TestFunc()int a = 20)&#123;&#125;//注意：如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用哪个缺省值 3.缺省值必须是常量或者全局变量4.C语言不支持（编译器不支持） 四.函数重载 函数重载的概念：是函数的的一种特殊情况，c++允许在同一作用域中声明几个功能相似的同名函数，这些同名函数的形参列表（参数个数或类型或顺序）必须不同，常用来处理或实现功能类似数据类型不同的问题。 123456789101112131415161718192021int Add(int left,int right)&#123; return left + right;&#125;double Add(double left, double right)&#123; return left + right;&#125;long Add(long left, long right)&#123; return left + right;&#125;int main()&#123; Add(10 , 20); Add(10.0 , 20.0); Add(10L , 20L)； return 0;&#125; extern “C”有时候在c++工程中可能需要将某些函数按照c的风格来编译，在函数前加extern “C”,意思是告诉编译器，将该函数按照C语言规则来编译。 1234567extern &quot;C&quot; int Add(int left, int right);int main()&#123; Add(1,2); return 0;&#125; 链接时报错：error LINK2019：无法解析的外部符号_Add，该符号在函数_main中被引用 引用引用概念：引用不是新定义一个变量，而是给已存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一快内存空间。类型&amp;引用变量名（对象名）= 引用实体 1234567void TestRef()&#123; int a = 10; int&amp; ra = a;//&lt;===定义引用类型 printf(&quot;%p&quot;,&amp;a); printf(&quot;%p&quot;,&amp;ra);&#125; 注意：引用类型必须和引用实体是同种类型。引用特性：1.引用在定义时必须初始化 2.一个变量可以有多个引用 3.引用一旦引用一个实体，再不能引用其他实体]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love You Forever]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Forever! Forever! Forever! How Deep Is Your Love 启窗以望，星瀚凌凌。望无路兮，无以所归。 昔既难忆，企留我心。抬首对穹，平嗓来歌。 裹卷相思，寄我爱人。孤孑一身。泪染两襟。 此出一曲，银河往替。凝眸流火，遥寄千里。 所落之处，记为老故。所思之疆，亦已焉哉。 没于黑弥，不得所终。凝空对唱，此歌凄哀。 告我所爱，知我所爱，可得故思，于此起风。 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
