<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[string类]]></title>
    <url>%2F2019%2F04%2F20%2Fstring%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[标准库中的string类 字符串是表示字符序列的类 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 string类是使用char（即作为它的字符类型，使用它的默认char_traits和分配器类型）。 string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数。 注意，这个类独立于所使用的编码来处理字节：如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。总结: string是表示字符串的字符串类 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作 string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char,char_traits,allocator&gt;string; 不能操作多字节或者变长字符的序列 在使用string类时，必须包含头文件以及using namespace std; string类的常用接口说明1. string类对象的常见构造 函数名称 功能说明 string() 构造空的string类对象，即空字符串 string(const char* s) 用C-string来构造string类对象 string(size_t n, char c) string类对象中包含n个字符c string(const string&amp; s) 拷贝构造函数 string(const string&amp; s, size_t n) 用s中的前n个字符构造新的string类对象 12345678void TestString()&#123; string s1; //构造空的string类对象s1 string s2(&quot;hello world&quot;); //用C格式字符串构造string类对象s2 string s3(10,&apos;a&apos;); //用10个字符&apos;a&apos;构造string类对象s3 string s4(s2); //拷贝构造s4 string s5(s3, 5); //用s3中前5个字符构造string对象s5&#125; 2. string类对象的容量操作 函数名称 功能说明 size_t size()const 返回字符串有效字符长度 size_t length()const 返回字符串有效字符长度 size_t capacity()const 返回空间总大小 bool empty()const 检测字符串是否为空串，是返回true,否则返回false void clear() 清空有效字符 void resize(size_t n,char c) 将有效字符的个数改成n个，多出的空间用字符c填充 void resize(size_t n) 将有效字符的个数改成n个，多出的空间用0填充 void reserve(size_t res_arg = 0) 为字符串预留空间 【注意】 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 clear()只是将string中有效字符清空,不改变底层空间大小。 reserve(size_t n)与resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时，reserve(n)用0来填充多出的元素空间，reserve(size_t n, char c)用字符c来填充多出的元素空间。注意: resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 reserve(size_t res, arg = 0): 为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小。 3.string类对象的访问操作 函数名称 功能说明 char&amp; operator 返回pos位置的字符，const string类对象调用 const char&amp; operator const 返回pos位置的字符，非const string类对象调用 1234567891011121314151617void TestString()&#123; String s1(&quot;hello world&quot;); const String s2(&quot;hello world&quot;); cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s1[0] &lt;&lt; &quot; &quot; &lt;&lt; s2[0] &lt;&lt; endl; s1[0] = &apos;H&apos;; cout &lt;&lt; s1 &lt;&lt; endl; for(size_t i = 0; i &lt; s1.size(); ++i) &#123; cout &lt;&lt; s1[i] &lt;&lt; endl; &#125; //s2[0] = &apos;h&apos;; 代码编译失败，因为const类型对象不能修改&#125; 4.string类对象的修改操作 函数名称 功能说明 void push_back(char c) 在字符串后尾插字符c string&amp; append(const char* s) 在字符串后追加一个字符串 string&amp; operator+=(const string&amp; str) 在字符串后追加字符串str string&amp; operator+=(char c) 在字符串后追加字符c const char* c_str()const 返回C格式字符串 size_t find(char c, size_t pos = 0) const 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置 size_t rfind(char c, size_t pos = npos) 从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置 string substr(size_t pos = 0, size_t n = npos) const 在str中从pos位置开始，截取n个字符，然后将其返回 【注意】 在string尾部追加字符时,s.push_back(a)/s.append(1,a)/s += ‘a’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预备好。 5.string类非成员函数 函数 功能说明 operator+ 尽量少用，因为效率低 operator&gt;&gt; 输入运算符重载 operator&lt;&lt; 输出运算符重载 getline 获取一行字符串 relational operators 大小比较]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数模板、类模板]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1.泛型编程怎样去实现一个通用的交换函数呢？ 12345678910111213141516171819202122void Swap(int&amp; left, int&amp; right)&#123; int temp = left; left = right; right = tmp;&#125;void Swap(double&amp; left, double&amp; right)&#123; double temp = left; left = right; right = temp;&#125;void Swap(char&amp; left, char&amp; right)&#123; char temp = left; left = right; right = temp;&#125;...... 使用函数重载虽然可以实现，但是有以下几个不好的地方 重载的函数仅仅只是类型不同，代码复用率较低，只要有新类型出现时，就需要增加时对应的函数 代码的可维护性比较低，一个出错可能所有的重载均出错 那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？ 泛型编程：编写与类型无关的通用代码，是代码复用的一种手段，模板是泛型编程的基础 2.函数模板2.1 函数模板概念函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本2.2 函数模板格式template返回值类型 函数名（参数列表）{} 1234567template&lt;typename T&gt;void Swap(T&amp; left, T&amp; right)&#123; T temp = left; left = right; right = temp;&#125; 注意：typename是用来定义模板参数的关键字，也可以使用class（切记，不能使用struct代替class）2.3 函数模板的原理模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具，所以其实模板就是将本来应该我们做的重复的事情交给了编译器在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用，比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。2.4 函数模板的实例化用不同类型的参数使用函数模板时，称为函数模板的实例化，模板参数实例化分为：隐式实例化和显式实例化 隐式实例化：让编译器根据实参推演模板参数的实际类型 123456789101112131415161718192021222324252627template&lt;class T&gt;T Add(const T&amp; left, const T&amp; right)&#123; return left + right;&#125;int main()&#123; int a1 = 10, a2 = 20; double d1 = 10.0, d2 = 20.0; Add(a1, a2); Add(d1, d2);/* Add(a1, d1); 该语句不能通过编译， 因为在编译期间， 当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参的d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int或者double类型而报错注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出现问题，编译器就需要背黑锅*///此时有两种处理方式：1.用户自己来强制转化 2.使用显式实例化 Add(a, (int)d); return 0;&#125; 显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型 123456789int main(void)&#123; int a = 10; double b = 20.0; //显式实例化 Add&lt;int&gt;(a, b); return 0;&#125; 如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。 2.5模板参数的匹配规则 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数 123456789101112131415161718//专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;//通用加法函数template&lt;class T&gt;T Add(T left, T right)&#123; return left + right;&#125;void Test()&#123; Add(1,2); //与非模板函数匹配，编译器不需要特化 Add&lt;int&gt;(1,2);//调用编译器特化的Add版本&#125; 对于非模板函数和同名函数模板，如果其他条件都相同，在调用时会优先调用非模板函数而不会从该模板产生出一个实例，如果模板可以产生一个具有良好匹配的函数，那么将选择模板 123456789101112131415161718//专门处理int的加法函数int Add(int left, int right)&#123; return left + right;&#125;//通用加法函数template&lt;class T1, class T2&gt;T1 Add(T1 left, T2 right)&#123; return left + right;&#125;void Test()&#123; Add(1, 2); //与非函数模板类型完全匹配，不需要函数模板实例化 Add(1, 2.0); //模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数&#125; 模板函数不允许自动类型转换，但普通函数可以进行自动类型转换3.类模板3.1 类模板的定义格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758template&lt;class T1,class T2,......,class Tn&gt;class 类模板名&#123; //类内容定义&#125;;//动态顺序表template&lt;class T&gt;class Vector&#123;public: Vector(size_t capacity = 10) :_pData(new T[capacity]) ,_size(0) ,_capacity(capacity) &#123;&#125; //使用析构函数演示，在类中声明，在类外定义。 ~Vector(); void PushBack(const T&amp; data) &#123; //_CheckCapacity(); _pData[_size++] = data; &#125; void PopBack() &#123; --_size; &#125; size_t Size() &#123; return _size; &#125; T&amp; operator[](size_t pos) &#123; assert(pos &lt; _size); return _pData[pos]; &#125; private: T* _pData; size_t _size; size_t _capacity;&#125;;//注意：类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;Vector&lt;T&gt;::~Vector()&#123; if(_pData) &#123; delete[] _pData; &#125;&#125; 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具 3.2类模板的实例化类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;,然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类 12345678910111213141516171819202122//Vector类名，Vector&lt;int&gt;才是类型Vector&lt;int&gt; s1;s1.PushBack(1);s1.PushBack(2);s1.PushBack(3);Vector&lt;double&gt; s2;s2.PushBack(1.0);s2.PushBack(2.0);s2.PushBack(3.0);for(size_t i = 0;i &lt; s1.size(); ++i)&#123; cout &lt;&lt; s1[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for(size_t i = 0; i &lt; s1.size() ; ++i)&#123; cout &lt;&lt; s2[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2F2019%2F04%2F18%2FC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.C/C++内存分布【说明】 栈又叫堆栈，非静态局部变量/函数参数/返回值等，栈是向下增长的。 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享内存，做进程间通信。 堆用于程序运行时动态内存分配，堆是可以向上增长的。 数据段-存储全局数据和静态数据。 代码段-可执行的代码/只读常量。2.C语言中动态内存管理方式2.1 malloc/calloc/realloc和free 12345678910void Test()&#123; int *p1 = (int*)malloc(sizeof(int)); free(p1); int* p2 = (int*)calloc(4, sizeof(int)); int* p3 = (int*)realloc(p2, sizeof(int)*10); free(p3);&#125; 3.C++内存管理方式C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式，通过new和delete操作符进行动态内存管理。3.1 new/delete 操作内置类型 12345678910111213141516void Test()&#123; //动态申请一个int类型的空间 int* ptr4 = new int; //动态申请一个int类型的空间并初始化为10 int* ptr5 = new int(10); //动态申请10个int类型的空间 int ptr6 = new int[10]; delete ptr4; delete ptr5; delete[] ptr6; //注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]&#125; 3.2 new和delete操作自定义类型 123456789101112131415161718192021222324252627class Test&#123;public: Test() :_data(0) &#123; cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl; &#125;private: int _data;&#125;;void Test()&#123; //申请单个Test类型的对象 Test* p1 = new Test; delete p1; //申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2;&#125; 【注意】：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc和free不会。 4. operator new与operator delete函数new和delete是用户进行动态内存申请和释放的操作符，operator new和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete底层通过operator delete全局函数来释放空间 1234567891011121314151617181920/*operator new: 该函数实际通过malloc来申请空间，当malloc&apos;申请空间成功时直接返回；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常*/void *_CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)&#123; //try to allocate size bytes void *p; while((p == malloc(size)) == 0) if(_callnewh(size) == 0) &#123; // report no memory //如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); &#125; return (p);&#125; operator new实际也是通过malloc来申请空间，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete最终是通过free来释放空间的 下面代码演示了，针对链表的节点ListNode通过重载类专属operator new/operator delete,实现链表节点使用内存池申请和释放内存，提高效率. 1234567891011121314151617181920struct LlistNode&#123; ListNode* _next; ListNode* _prev; int _data; void* operator new(size_t n) &#123; void* p = nullptr; p = allocator&lt;ListNode&gt;().allocate(1); cout &lt;&lt; &quot;memory pool allocate&quot; &lt;&lt; endl; return p; &#125; void operator delete(void* p) &#123; allocator&lt;ListNode&gt;().deallocate((ListNode*)p, 1); cout &lt;&lt; &quot;memory pool deallocate&quot; &lt;&lt; endl; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334class List&#123;public: List() &#123; _head = new ListNode; _head-&gt;next = _head; _head-&gt;prev = _head; &#125; ~List() &#123; ListNode* cur = _head-&gt;next; while(cur != _head) &#123; ListNode* next = cur-&gt;_next; delete cur; cur = next; &#125; delete _head; _head = nullptr; &#125;private: ListNode* _head;&#125;;int main()&#123; List l; return 0;&#125; 5.new和delete的实现原理5.1 内置类型如果申请的是内置类型空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时就会抛异常，malloc会返回NULL。5.2 自定义类型 new的原理 1. 调用operator new函数申请空间 2. 在申请的空间上执行构造函数，完成对象的构造 delete的原理 1. 在空间上执行析构函数，完成对象中的资源清理工作 2. 调用operator delete函数释放对象的空间 new T[N]的原理 1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请 2. 在申请的空间上执行N此构造函数 delete[]的原理 1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间 6. 内存泄漏6.1 什么是内存泄漏内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄露并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费 123456789101112void MemoryLeaks()&#123; // 1.内存申请了忘记释放 int *p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p2 = new int[10]; Func(); // 这里Func函数抛异常导致delete[] p3未执行，p3没有被释放 delete[] p3;&#125; 6.2 内存泄漏分类 堆内存泄漏（Heap leak） 堆内存指的是程序执行中依据须要分配通过malloc/calloc/realloc/new等从堆中分配的一块内存，用完后必须通过调用相应的free或delete删掉，加入程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生内存泄漏。 系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 6.3 如何避免内存泄漏 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps: 这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出现问题。需要下一条智能指针来管理才有保证。 采用RAII思想或者只能指针来管理资源。 有些公司内部规范使用内部实现的私有内存管理库，这套库自带内存泄漏检测的功能选项。 出问题了使用内存泄漏工具检测。ps: 不过很多工具都不够靠谱，或者收费昂贵。 【总结】内存泄漏非常常见，解决方案分为两种：1.事先预防型，如智能指针等。2.事后查错型。如泄漏检测工具。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解static、内部类、友元函数]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%90%86%E8%A7%A3static%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 再谈构造函数1.1 构造函数体赋值在创建对象时，编译器通过调用构造函数，给对象各个成员变量一个合适的初始值 123456789101112131415class Date&#123;public: Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125; private: int _year; int _month; int _day;&#125;; 虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造函数体中的语句只能将其称作为赋初值，而不能称作初始化，因为初始化只能初始化一次，而构造函数体内可以多次赋值。 1.2 初始化列表初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个成员变量后面跟一个放在括号中的初始值或表达式 1234567891011121314class Date&#123;public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125;private: int _year; int _month; int _day;&#125;; 【注意】 1.每个成员变量在初始化列表中只能出现一次（初始化只能出现一次） 2.类中包含以下成员，必须放在初始化列表位置进行初始化： 引用成员变量 const成员变量 类类型成员变量（该类没有默认构造函数）12345678910111213141516171819202122class A&#123;public: A(int a) :_a(a) &#123;&#125;private: int _a;&#125;;class B&#123;public: B(int a, int ref) :_aobj(a) ,_ref(ref) ,_n(10) &#123;&#125;private: A _aobj; //没有默认构造函数 int&amp; ref; //引用 const int _n; //const&#125;; 尽量使用初始化列表初始化， 因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。 123456789101112131415161718192021222324252627class Time&#123;public: Time(int hour = 0) :_hour(hour) &#123; cout &lt;&lt; &quot;Time()&quot; &lt;&lt; endl; &#125;private: int _hour;&#125;;class Date&#123;public: Date(int day) &#123;&#125;private: int _day; Time _t;&#125;;int main()&#123; Date d(1);&#125; 4.成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关 1234567891011class Array&#123;public: Array(int size) :_size(size) ,_array((int*)malloc(sizeof(int)*_size)) &#123;&#125;private: int* _array; int _size;&#125; 1.3 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用 12345678910111213141516171819202122class Date&#123;public: Date(int year) :_year(year) &#123;&#125; explicit Date(int year) :_year(year) &#123;&#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1(2018); //用一个整型变量给日期类型对象赋值 //实际编译器背后会用2019构造一个无名对象， 最后用无名对象给d1对象进行赋值 d1 = 2019;&#125; 上述代码可读性不是很好，用explicit修是构造函数，将会禁止单参构造函数的隐式转换。 2.static成员2.1 概念声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量;用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化 面试题：实现一个类，计算程序中创建出了多少个类对象。 12345678910111213141516171819202122class A&#123;public: A() &#123;++_scount;&#125; A(const A&amp; t) &#123;++_scount;&#125; static int GetACount() &#123;return _scount;&#125;private: static int _scount;&#125;;int Test::_count = 0;void TestA()&#123; cout &lt;&lt; A::GetACount() &lt;&lt; endl; A a1, a2; A a3(a1); cout &lt;&lt; A:: GetACount() &lt;&lt; endl;&#125; 2.2 特性 1.静态成员为所有类对象所共享，不属于某个具体的实例 2.静态成员变量必须在类外定义，定义时不添加static关键字 3.类静态成员即可用类名::静态成员或者对象。静态成员来访问 4.静态成员函数没有隐藏的this指针，不能访问任何非静态成员 5.静态成员和类的普通成员一样，也是public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数。 3.C++的成员初始化新用法c++支持非静态成员变量在声明时，直接初始化 123456789101112131415161718192021222324252627282930313233343536class B&#123;public: B(int b = 0) :_b(b) &#123;&#125; int _b;&#125;;class A&#123;public: void Print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b._b &lt;&lt;endl; cout &lt;&lt; p &lt;&lt; endl; &#125;private: //非静态成员变量，可以在成员声明时，直接初始化 int a = 10; B b = 20; int* p = (int*)malloc(4); static int n; &#125;;int A::n = 10;int main()&#123; A a; a.Print(); return 0;&#125; 4.友元友元分为： 友元函数和友元类友元提供了一种突破封装的方式，有时提供了便利，但是友元会增加耦合度，破坏了封装，所以友元不宜多用。4.1 友元函数问题：现在我们尝试去重载operate&lt;&lt;，然后发现我们没办法将operate&lt;&lt;重载成成员函数。因为cout输出流对象和隐含的this指针抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。 1234567891011121314151617181920212223242526class Date&#123;public: Date(int year, int month,int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125; ostream&amp; operator&lt;&lt;(ostream&amp; _cout) &#123; _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d(2018, 12, 24); d &lt;&lt; cout; return 0;&#125; 友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。 12345678910111213141516171819202122232425262728293031323334353637class Date&#123;friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);friend istream&amp; operator&gt;&gt;(istream&amp; _cin,const Date&amp; d);public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) &#123;&#125;private: int _year; int _month; int _day;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)&#123; _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout;&#125;istream&amp; operator&gt;&gt;(istream&amp; _cin, const Date&amp; d)&#123; _cin &gt;&gt; d._year; _cin &gt;&gt; d._month; _cin &gt;&gt; d._day; return _cin;&#125;int main()&#123; Date d; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 说明： 友元函数可以访问类的私有成员，但不是类的成员函数 友元函数不能用const修饰 友元函数可以在类定义的任何地方声明，不受访问限定符限制 一个函数可以是多个类的友元函数 友元函数的调用与普通函数的调用和原理相同 4.2 友元类友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员 友元函数是单向的，不具有交换性比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行 友元关系不能传递如果B是A的友元，C是B的友元，则不能说明C是A的友元 12345678910111213141516171819202122232425262728293031323334353637383940class Date; //前置声明class Time&#123; friend class Date; //声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量public: Time(int hour, int minute, int second) : _hour(hour) , _minute(minute) ,_second(second) &#123;&#125;private: int _hour; int _minute; int _second;&#125;;class Date&#123;public: Date(int year = 1900, int month = 1, int day = 1) : _year(year) , _month(month) , _day(day) &#123;&#125; void SetTimeOfDate(int hour, int minute, int second) &#123; //直接访问时间类私有的成员变量 _t._hour = hour; _t._minute = minute; _t._second = second; &#125;private: int _year; int _month; int _day; Time _t;&#125;; 5.内部类5.1 概念及特性概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类，外部类对内部类没有任何优越的访问权限。注意：内部类就是外部类的友元类。注意友元类的定义。内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。 特性： 内部类可以定义在外部类的public、projected、private都是可以的。 注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 sizeof(外部类) = 外部类，和内部类没有任何关系。 1234567891011121314151617181920212223242526class A&#123;private: static int k; int h;public: class B &#123; public: void foo(const A&amp; a) &#123; cout &lt;&lt; k &lt;&lt; endl; //OK cout &lt;&lt; a.h &lt;&lt; endl; //OK &#125; &#125;;&#125;;int A::k = 1;int main()&#123; A::B b; b.foo(A()); return 0;&#125; 6.再次理解封装c++是基于面向对象的程序，面向对象有三大特性即： 封装、继承、多态。 c++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起；通过访问限定符选择性的将其部分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让整个事情复杂化。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的六个默认成员函数如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并非如此，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。class Date {}; 1.构造函数·1.1 概念 构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。1.2 特性 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称是构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。 其特征如下： 1.函数名与类名相同 2.无返回值 3.对象实例化时编译器自动调用对应的构造函数 4.构造函数可以重载 12345678910111213141516171819202122232425262728class Date&#123;public: //1.无参构造函数 Date() &#123;&#125; //2.带参构造函数 Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1;//调用无参构造函数 Date d2(2015, 1, 1);//调用带参构造函数 //注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明 //以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象 Date d3();&#125; 5.如果类中没有显式定义构造函数，则c++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。6.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个，注意：无参构造函数，全缺省构造函数，我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。7.c++把类型分成内置类型（基本类型）和自定义类型。内置类型就是语法已经定义好的类型：如 int/char….，自定义类型就是我们使用class/struct/union自己定义的类型，编译器生成的默认构造函数会调用自定义类型的默认构造函数. 2.析构函数2.1 概念析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的，而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。2.2 特性析构是特殊的成员函数。特征如下：1.析构函数名是在类名前加上字符~2.无参数无返回值3.一个类有且只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数4.对象生命周期结束时，c++编译系统系统自动调用析构函数5.编译器生成的默认析构函数，对会自定类型成员调用它的析构函数 3.拷贝构造函数3.1 概念构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），再用已存在的类类型对象创建新对象时由编译器自动调用。3.2 特征1.拷贝构造函数是构造函数的一个重载形式2.拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式对引发无穷递归调用 12345678910111213141516171819202122232425262728class Date&#123; Date(int _year = 1900, int _month = 1,int _day = 1) &#123; _year = year; _month = month; _day = day; &#125; Date(const Date&amp; d) &#123; _year = d.year; _month = d.month; _day = d.day; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1; Date d2(d1); return 0;&#125; 3.若未显式定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝。 4.赋值运算符重载4.1 运算符重载c++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型operator操作符（参数列表）注意：1.不能通过连接其他符号来创建新的操作符：比如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，例如：内置的类型+，不能改变其含义。4.作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参5.、::、sizeof、？:、.注意以上五个运算符不能重载。5.2 赋值运算符重载赋值运算符主要有四点：1.参数类型2.返回值3.检测是否自己给自己赋值4.返回this5.一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝 6.const成员6.1 const修饰类的成员函数将const修饰的类的成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。6.2 有以下需要注意的点1.const对象不可以调用非const成员函数2.非const对象可以调用const成员函数3.const成员函数内不可以调用其他的非const成员函数4.非const成员函数内可以调用其它的const成员函数 7.取地址及const取地址操作符重载123456789101112131415161718这两个默认成员函数一般不用重新定义，编译器默认会生成class Date&#123;public: Date* operator&amp;() &#123; return this; &#125; const Date* operator&amp;()const &#123; return this; &#125; private: int _year; int _monthl int _day;&#125;; 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载比如想让别人获取到指定的内容！]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The_first_blog]]></title>
    <url>%2F2019%2F04%2F04%2FThe-first-blog%2F</url>
    <content type="text"><![CDATA[C++基础相关知识一.命名空间在c/c++中，变量、函数、类都是大量存在的，这些函数、变量和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或命名污染，namespace关键字的出现就是为了避免这种问题。 //1.普通的命名空间 namespace N1 //N1为命名空间的名称 { //命名空间的内容，可以定义变量，也可以定义函数 int a; int Add(int left , int right) { return left + right; } } //2.命名空间可以嵌套 namespace N2 { int a; int b; int Add(int left , int left) { return left + right; } namespace N3 { int c; int d; int sub( int left,int right ) { return left - right; } } } //3.同一个工程中允许存在多个相同名称的命名空间 // 编译器最终会合成同一个命名空间中 namespace N1 { int Mul(int left , int right) { return left*right; } } 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限与该命名空间中 二.c++输入&amp;输出12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello world!!&quot;&lt;&lt;endl; return 0;] 1.使用cout标准输出（控制台）和cin标准输入（键盘）时，必须包含头文件以及std标准命名空间。 注意：早期标准库将所有功能在全局域中实现，声明在.h后面的头文件中，使用时只需包含对应头文 件即可，后来将其实现在std命名空间下，为了和c头文件区分，也为了正确使用命名空间，规定 c++头文件不带.h;旧编译器（vc 6.0）中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐 使用+std的方式。 2.使用c++输入输出更方便，不需增加数据结构的控制。比如：整型-%d，字符-%c。 三. 缺省参数概念：缺省参数就是声明或定义时为函数的参数指定一个默认值。在调用函数时，如果没有指定实参则采用该默认值，否则使用指定实参。 12345678910void TestFunc(int a = 0)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;int main()&#123; TestFunc();//没有传参时，使用参数的默认值 TestFunc(10);//传参时使用指定实参&#125; 参数缺省分类全缺省参数: 123456void TestFunc(int a = 10,int b = 20, int c = 30)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 半缺省参数 1234567void TestFunc(int a, int b = 10,int c = 20)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 注意： 1.半缺省参数必须从右往左依次来给出，不能间隔着来给 2.缺省参数不能在函数声明和定义时同时出现。 123456//a.hvoid TestFunc(int a = 10);//a.cvoid TestFunc()int a = 20)&#123;&#125;//注意：如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用哪个缺省值 3.缺省值必须是常量或者全局变量4.C语言不支持（编译器不支持） 四.函数重载 函数重载的概念：是函数的的一种特殊情况，c++允许在同一作用域中声明几个功能相似的同名函数，这些同名函数的形参列表（参数个数或类型或顺序）必须不同，常用来处理或实现功能类似数据类型不同的问题。 123456789101112131415161718192021int Add(int left,int right)&#123; return left + right;&#125;double Add(double left, double right)&#123; return left + right;&#125;long Add(long left, long right)&#123; return left + right;&#125;int main()&#123; Add(10 , 20); Add(10.0 , 20.0); Add(10L , 20L)； return 0;&#125; extern “C”有时候在c++工程中可能需要将某些函数按照c的风格来编译，在函数前加extern “C”,意思是告诉编译器，将该函数按照C语言规则来编译。 1234567extern &quot;C&quot; int Add(int left, int right);int main()&#123; Add(1,2); return 0;&#125; 链接时报错：error LINK2019：无法解析的外部符号_Add，该符号在函数_main中被引用 引用引用概念：引用不是新定义一个变量，而是给已存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一快内存空间。类型&amp;引用变量名（对象名）= 引用实体 1234567void TestRef()&#123; int a = 10; int&amp; ra = a;//&lt;===定义引用类型 printf(&quot;%p&quot;,&amp;a); printf(&quot;%p&quot;,&amp;ra);&#125; 注意：引用类型必须和引用实体是同种类型。引用特性：1.引用在定义时必须初始化 2.一个变量可以有多个引用 3.引用一旦引用一个实体，再不能引用其他实体]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love You Forever]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Forever! Forever! Forever! How Deep Is Your Love 启窗以望，星瀚凌凌。望无路兮，无以所归。 昔既难忆，企留我心。抬首对穹，平嗓来歌。 裹卷相思，寄我爱人。孤孑一身。泪染两襟。 此出一曲，银河往替。凝眸流火，遥寄千里。 所落之处，记为老故。所思之疆，亦已焉哉。 没于黑弥，不得所终。凝空对唱，此歌凄哀。 告我所爱，知我所爱，可得故思，于此起风。 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
