<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[类和对象]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的六个默认成员函数如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并非如此，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。class Date {}; 1.构造函数·1.1 概念 构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。1.2 特性 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称是构造，但是需要注意的是构造函数的主要任务并不是开空间创建对象，而是初始化对象。 其特征如下： 1.函数名与类名相同 2.无返回值 3.对象实例化时编译器自动调用对应的构造函数 4.构造函数可以重载 12345678910111213141516171819202122232425262728class Date&#123;public: //1.无参构造函数 Date() &#123;&#125; //2.带参构造函数 Date(int year, int month, int day) &#123; _year = year; _month = month; _day = day; &#125;private: int _year; int _month; int _day;&#125;;void TestDate()&#123; Date d1;//调用无参构造函数 Date d2(2015, 1, 1);//调用带参构造函数 //注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明 //以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象 Date d3();&#125; 5.如果类中没有显式定义构造函数，则c++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。6.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个，注意：无参构造函数，全缺省构造函数，我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。7.c++把类型分成内置类型（基本类型）和自定义类型。内置类型就是语法已经定义好的类型：如 int/char….，自定义类型就是我们使用class/struct/union自己定义的类型，编译器生成的默认构造函数会调用自定义类型的默认构造函数. 2.析构函数2.1 概念析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的，而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。2.2 特性析构是特殊的成员函数。特征如下：1.析构函数名是在类名前加上字符~2.无参数无返回值3.一个类有且只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数4.对象生命周期结束时，c++编译系统系统自动调用析构函数5.编译器生成的默认析构函数，对会自定类型成员调用它的析构函数 3.拷贝构造函数3.1 概念构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），再用已存在的类类型对象创建新对象时由编译器自动调用。3.2 特征1.拷贝构造函数是构造函数的一个重载形式2.拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式对引发无穷递归调用 12345678910111213141516171819202122232425262728class Date&#123; Date(int _year = 1900, int _month = 1,int _day = 1) &#123; _year = year; _month = month; _day = day; &#125; Date(const Date&amp; d) &#123; _year = d.year; _month = d.month; _day = d.day; &#125;private: int _year; int _month; int _day;&#125;;int main()&#123; Date d1; Date d2(d1); return 0;&#125; 3.若未显式定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝。 4.赋值运算符重载4.1 运算符重载c++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型operator操作符（参数列表）注意：1.不能通过连接其他符号来创建新的操作符：比如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，例如：内置的类型+，不能改变其含义。4.作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参5.、::、sizeof、？:、.注意以上五个运算符不能重载。5.2 赋值运算符重载赋值运算符主要有四点：1.参数类型2.返回值3.检测是否自己给自己赋值4.返回this5.一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝 6.const成员6.1 const修饰类的成员函数将const修饰的类的成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。6.2 有以下需要注意的点1.const对象不可以调用非const成员函数2.非const对象可以调用const成员函数3.const成员函数内不可以调用其他的非const成员函数4.非const成员函数内可以调用其它的const成员函数 7.取地址及const取地址操作符重载123456789101112131415161718这两个默认成员函数一般不用重新定义，编译器默认会生成class Date&#123;public: Date* operator&amp;() &#123; return this; &#125; const Date* operator&amp;()const &#123; return this; &#125; private: int _year; int _monthl int _day;&#125;; 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载比如想让别人获取到指定的内容！]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The_first_blog]]></title>
    <url>%2F2019%2F04%2F04%2FThe-first-blog%2F</url>
    <content type="text"><![CDATA[C++基础相关知识一.命名空间在c/c++中，变量、函数、类都是大量存在的，这些函数、变量和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或命名污染，namespace关键字的出现就是为了避免这种问题。 //1.普通的命名空间 namespace N1 //N1为命名空间的名称 { //命名空间的内容，可以定义变量，也可以定义函数 int a; int Add(int left , int right) { return left + right; } } //2.命名空间可以嵌套 namespace N2 { int a; int b; int Add(int left , int left) { return left + right; } namespace N3 { int c; int d; int sub( int left,int right ) { return left - right; } } } //3.同一个工程中允许存在多个相同名称的命名空间 // 编译器最终会合成同一个命名空间中 namespace N1 { int Mul(int left , int right) { return left*right; } } 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限与该命名空间中 二.c++输入&amp;输出12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;hello world!!&quot;&lt;&lt;endl; return 0;] 1.使用cout标准输出（控制台）和cin标准输入（键盘）时，必须包含头文件以及std标准命名空间。 注意：早期标准库将所有功能在全局域中实现，声明在.h后面的头文件中，使用时只需包含对应头文 件即可，后来将其实现在std命名空间下，为了和c头文件区分，也为了正确使用命名空间，规定 c++头文件不带.h;旧编译器（vc 6.0）中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐 使用+std的方式。 2.使用c++输入输出更方便，不需增加数据结构的控制。比如：整型-%d，字符-%c。 三. 缺省参数概念：缺省参数就是声明或定义时为函数的参数指定一个默认值。在调用函数时，如果没有指定实参则采用该默认值，否则使用指定实参。 12345678910void TestFunc(int a = 0)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;int main()&#123; TestFunc();//没有传参时，使用参数的默认值 TestFunc(10);//传参时使用指定实参&#125; 参数缺省分类全缺省参数: 123456void TestFunc(int a = 10,int b = 20, int c = 30)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 半缺省参数 1234567void TestFunc(int a, int b = 10,int c = 20)&#123; cout&lt;&lt;&quot;a = &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b = &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;&#125; 注意： 1.半缺省参数必须从右往左依次来给出，不能间隔着来给 2.缺省参数不能在函数声明和定义时同时出现。 123456//a.hvoid TestFunc(int a = 10);//a.cvoid TestFunc()int a = 20)&#123;&#125;//注意：如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用哪个缺省值 3.缺省值必须是常量或者全局变量4.C语言不支持（编译器不支持） 四.函数重载 函数重载的概念：是函数的的一种特殊情况，c++允许在同一作用域中声明几个功能相似的同名函数，这些同名函数的形参列表（参数个数或类型或顺序）必须不同，常用来处理或实现功能类似数据类型不同的问题。 123456789101112131415161718192021int Add(int left,int right)&#123; return left + right;&#125;double Add(double left, double right)&#123; return left + right;&#125;long Add(long left, long right)&#123; return left + right;&#125;int main()&#123; Add(10 , 20); Add(10.0 , 20.0); Add(10L , 20L)； return 0;&#125; extern “C”有时候在c++工程中可能需要将某些函数按照c的风格来编译，在函数前加extern “C”,意思是告诉编译器，将该函数按照C语言规则来编译。 1234567extern &quot;C&quot; int Add(int left, int right);int main()&#123; Add(1,2); return 0;&#125; 链接时报错：error LINK2019：无法解析的外部符号_Add，该符号在函数_main中被引用 引用引用概念：引用不是新定义一个变量，而是给已存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一快内存空间。类型&amp;引用变量名（对象名）= 引用实体 1234567void TestRef()&#123; int a = 10; int&amp; ra = a;//&lt;===定义引用类型 printf(&quot;%p&quot;,&amp;a); printf(&quot;%p&quot;,&amp;ra);&#125; 注意：引用类型必须和引用实体是同种类型。引用特性：1.引用在定义时必须初始化 2.一个变量可以有多个引用 3.引用一旦引用一个实体，再不能引用其他实体]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love You Forever]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Forever! Forever! Forever! How Deep Is Your Love 启窗以望，星瀚凌凌。望无路兮，无以所归。 昔既难忆，企留我心。抬首对穹，平嗓来歌。 裹卷相思，寄我爱人。孤孑一身。泪染两襟。 此出一曲，银河往替。凝眸流火，遥寄千里。 所落之处，记为老故。所思之疆，亦已焉哉。 没于黑弥，不得所终。凝空对唱，此歌凄哀。 告我所爱，知我所爱，可得故思，于此起风。 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
